---
layout: post
title: "[MM’s] Boot Notes — Resilience patterns made simple with Spring Boot 4."
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-resilience-patterns-made-simple-with-spring-boot-4-b0d127d8ba33?source=rss-f1368b7746f7------2
tag:
- resilience4j
- java
- spring-retry
- spring-boot
- programming
---

<h3>[MM’s] Boot Notes — Resilience patterns made simple with Spring Boot 4.</h3><h4>Fortify Your Microservices with <a href="http://twitter.com/Retryable">Retryable</a> and <a href="http://twitter.com/ConcurrencyLimit">ConcurrencyLimit</a></h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LwrML4JBEtbvx4MwzKKHSw.png" /><figcaption>Resilience patterns made simple with Spring Boot 4.</figcaption></figure><p>Hey Spring community! With the new release of Spring Boot 4 (built on the powerful new Spring Framework 7), a set of fantastic, built-in resilience tools are now at our fingertips. In a world of distributed systems, network hiccups and service overloads aren’t just possible — they’re inevitable.</p><p>Today, we’ll take a hands-on look at how the new @Retryable and @ConcurrencyLimit annotations can transform a fragile component into a robust, self-healing one.</p><h4>The Scenario: An Unreliable API Call</h4><p>Imagine we have a service that needs to call an external RESTful API. This API can sometimes be slow or return transient errors like a 503 Service Unavailable.</p><p>Our initial code might look something like this. Simple, clean, but prone to breaking in edge cases.</p><pre>@Service<br>public class DataService {<br><br>    private final RestfulApiClient client;<br><br>    public DataService(RestfulApiClient client) {<br>        this.client = client;<br>    }<br><br>    public RestfulApiResponse processRequest(String key) {<br>        return this.client.getResponse(key);<br>    }<br>}</pre><p>What happens if the processRequest() method throws a GatewayTimeoutException? The operation fails, an error is logged and our user gets a frustrating experience.</p><h4>Step 1: Automatically Retrying Failures with @Retryable 🔁</h4><p>Transient errors, like temporary network blips, are perfect candidates for a retry. Instead of failing immediately, let’s just try again! With Spring Boot 4, this is incredibly simple.</p><p>First, we need to enable the new resilience capabilities in our configuration:</p><pre>@Configuration<br>@EnableResilientMethods<br>public class ResilienceConfig {}</pre><p>Now, we can annotate our method with @Retryable.</p><pre>@Service<br>public class AnnotationBasedRetryService {<br><br>    //...<br><br>    @Retryable(includes = GatewayTimeoutException.class, maxAttempts = 4, multiplier = 2)<br>    public RestfulApiResponse processRequest(String key) {<br>        return this.client.getResponse(key);<br>    }<br>}</pre><p>With a single annotation, we’ve added powerful functionality:</p><ul><li>includes = GatewayTimeoutException.class: We only want to retry on this specific, transient exception.</li><li>maxAttempts = 4: It will try the operation up to 4 more times after the initial failure.</li><li>multiplier = 2: We&#39;re using an exponential back-off strategy. The delay between retries will double each time (e.g., 1s, 2s, 4s, 8s), which is a best practice to avoid hammering a struggling service.</li></ul><p>Our service can now automatically recover from temporary API failures without any complex try-catch loops or manual state management.</p><h4>Step 2: Preventing Overload with @ConcurrencyLimit 🚦</h4><p>Our service is now resilient to failures, but what if our <em>own application</em> is the source of the problem? If we get a sudden spike in traffic, our processRequest method might be called by hundreds of requests at once, overwhelming the external API and causing it to fail or throttle us.</p><p>This is especially important when using Virtual Threads, where the number of concurrent tasks can be massive. Let’s safeguard our downstream dependency using @ConcurrencyLimit.</p><pre>@Service<br>public class AnnotationBasedRetryService {<br><br>    //...<br><br>    @ConcurrencyLimit(15) // Only 15 concurrent executions allowed<br>    @Retryable(includes = GatewayTimeoutException.class, maxAttempts = 4, multiplier = 2)<br>    public RestfulApiResponse processRequest(String key) {<br>        return this.client.getResponse(key);<br>    }<br>}</pre><p>By adding @ConcurrencyLimit(15), we&#39;ve created a safeguard. Spring will now ensure that no more than 15 concurrent invocations of processRequest are running at any given time. The 16th request will simply wait until one of the previous 15 has completed. This acts as a protective throttle, preventing us from overwhelming the external API and improving the overall stability of the system.</p><h4>Alternative approach: Programmatic Control with RetryTemplate</h4><p>Annotations are perfect for most use cases, but sometimes you need more fine-grained control within a method. For these scenarios, Spring provides the RetryTemplate.</p><p>You can create a RetryPolicy with the exact same back-off and exception rules and then wrap any piece of code in a retryable block.</p><pre>@Service<br>public class ProgrammaticBasedRetryService {<br><br>    private final RestfulApiClient client;<br>    private final RetryTemplate template;<br><br>    public ProgrammaticBasedRetryService(RestfulApiClient client) {<br>        this.client = client;<br>        var retryPolicy = RetryPolicy.builder()<br>                .includes(GatewayTimeoutException.class)<br>                .maxAttempts(4)<br>                .delay(Duration.ofMillis(200))<br>                .build();<br>        this.template = new RetryTemplate(retryPolicy);<br>    }<br><br>    public RestfulApiResponse processRequest(String key) {<br>        try {<br>            return template.execute(() -&gt; this.client.getResponse(key));<br>        } catch (RetryException e) {<br>            throw new GatewayTimeoutException(e.getCause());<br>        }<br>    }<br>}</pre><p>This gives you the power of programmatic retries exactly where you need it.</p><h3>How Does This Compare to Resilience4j?</h3><p>Many of you are likely familiar with <a href="https://resilience4j.readme.io/docs/getting-started"><strong>Resilience4j</strong></a>, a mature library for fault tolerance. So, when should you use the new built-in Spring features and when should you reach for Resilience4j?</p><p>Think of it as a matter of scope and need:</p><p><strong>Core Spring Resilience<br></strong>✅ Provides essentials: <strong>Retry</strong> and <strong>Concurrency Throttling<br></strong>✅ Built-in, no dependencies, just @EnableResilientMethods<br>✅ Great for 80% of common use cases</p><p><strong>Resilience4j<br></strong>🔧 Offers a <strong>full toolkit</strong>: Circuit Breaker, Rate Limiter, Bulkhead, Retry, Time Limiter, Cache<br>➕ Requires external dependency (library + Spring Boot starter)<br>🎯 Best when you need <strong>fine-grained, advanced resilience control</strong></p><p><strong>Bottom Line:</strong></p><ul><li><strong>Use the new Core Spring Resilience features:</strong> Your primary needs are retry and concurrency limiting, and you prefer to have these essentials provided directly by the framework without adding new dependencies.</li><li><strong>Stick with Resilience4j:</strong> You require more advanced patterns like <strong>Circuit Breaker</strong> or <strong>Rate Limiter</strong>. If you need a complete, highly configurable fault-tolerance toolkit for complex scenarios, Resilience4j remains the premier choice.</li></ul><p>The new features aren’t a replacement for Resilience4j, but rather a powerful, integrated starting point for building more reliable applications.</p><h3>Conclusion</h3><p>The new resilience features baked directly into Spring Framework 7 and made effortlessly available in Spring Boot 4 are a game-changer for building robust applications. By combining @Retryable and @ConcurrencyLimit, we can easily:</p><ul><li><strong>Improve reliability</strong> by automatically handling transient failures.</li><li><strong>Increase stability</strong> by protecting downstream services from being overwhelmed.</li><li><strong>Write cleaner code</strong> by replacing boilerplate logic with declarative annotations.</li></ul><h3>💡 Best Practices</h3><ul><li><strong>Target exceptions</strong>: Always specify includes/excludes in @Retryable to avoid retrying on non-transient errors (e.g., 401 Unauthorized, NullPointerException).</li><li><strong>Use backoff</strong>: Apply a multiplier for exponential backoff to prevent hammering a struggling service.</li><li><strong>Limit attempts</strong>: Keep maxAttempts reasonable; too many retries can hurt user experience.</li><li><strong>Set guardrails</strong>: Choose @ConcurrencyLimit based on downstream capacity, not just your app’s.</li><li><strong>Combine smartly</strong>: Retries handle hiccups; concurrency limits prevent overload.</li><li><strong>Measure &amp; tune</strong>: Monitor retries, wait times, and errors — adjust settings with real-world data.</li></ul><p>Discover what’s new in Spring Boot 4 and make your services more resilient.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b0d127d8ba33" width="1" height="1" alt="">

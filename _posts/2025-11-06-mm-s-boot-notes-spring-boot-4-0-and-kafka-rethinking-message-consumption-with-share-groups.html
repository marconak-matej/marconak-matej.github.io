---
layout: post
title: "[MM’s] Boot Notes — Spring Boot 4.0 and Kafka: Rethinking Message Consumption
  with Share Groups"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-spring-boot-4-0-and-kafka-rethinking-message-consumption-with-share-groups-e7c4e9fc1a1d?source=rss-f1368b7746f7------2
tag:
- java
- spring-boot
- programming
- kafka
---

<h3>[MM’s] Boot Notes — Spring Boot 4.0 and Kafka: Rethinking Message Consumption with Share Groups</h3><h4>Inside Share Groups: Why Your Next Kafka Consumer Doesn’t Need to Care About Partitions (and Gets Broker-Managed Retries).</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XaAORREL8xZe9mZE_ZfmHg.jpeg" /><figcaption>Spring Boot 4.0 and Kafka: Rethinking Message Consumption with Share Groups</figcaption></figure><p>Every Kafka developer has been there: staring at a topic with hundreds of partitions, trying to squeeze more throughput out of a system that was designed for ordering. You scale partitions to match consumer count, tweak rebalance settings and still end up juggling complexity. It’s efficient, but inflexible.</p><p>Spring Boot 4.0 changes that equation with <strong>native support for Kafka Share Groups</strong> — a new model that breaks free from partition-based consumption. Instead of assigning partitions to consumers, Share Groups distribute individual records across all available consumers. Think of it as <strong>true queue semantics for Kafka</strong>, finally built into the platform.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li><strong>Share Groups distribute records, not partitions</strong>, enabling queue-like consumption patterns.</li><li><strong>Spring Boot 4.0 adds first-class support</strong> via familiar @KafkaListener APIs and Share Consumer factories.</li><li><strong>Concurrency control is built-in</strong>, allowing multiple consumer threads per instance.</li><li><strong>Three acknowledgment types</strong> — ACCEPT, RELEASE, and REJECT — provide broker-managed retry and poison message handling.</li></ul><h4>Why Partitions Became a Bottleneck</h4><p>Traditional Kafka consumer groups provide <strong>partition-level ownership</strong> — each partition belongs to exactly one consumer. That’s great for ordered workflows, but a poor fit for independent workloads like image processing or background jobs. To increase throughput, you must increase partitions, which adds operational overhead and rebalancing complexity.</p><p>Want 100 parallel consumers? You need 100 partitions — and once they’re created, scaling down isn’t straightforward. Partitions are your concurrency ceiling. For many teams, that’s been Kafka’s hidden tax.</p><h4>Share Groups: A New Consumption Model</h4><p>Kafka 4.0 introduces <strong>Share Groups</strong> (KIP-932), and Spring Boot 4.0 brings them natively to the Spring ecosystem. Instead of assigning partitions to consumers, the broker distributes records dynamically among all active members of a share group.</p><p>Key differences at a glance:</p><ul><li><strong>Traditional model:</strong> Assigns partitions → <strong>Share Groups:</strong> Distribute records</li><li><strong>Traditional:</strong> Consumers track offsets → <strong>Share Groups:</strong> Broker tracks record state</li><li><strong>Traditional:</strong> Apps handle retries → <strong>Share Groups:</strong> Broker manages redelivery and poison messages</li><li><strong>Traditional:</strong> Scaling triggers rebalancing → <strong>Share Groups:</strong> Add consumers seamlessly</li></ul><p>The result? You get Kafka’s reliability with RabbitMQ-style flexibility.</p><h4>When to Use (and Avoid) Share Groups</h4><p>Share Groups aren’t a replacement for consumer groups — they’re complementary.</p><p><strong>Use Share Groups when:</strong></p><ul><li>Order doesn’t matter — e.g., image processing, notifications, job queues.</li><li>Workload volume fluctuates and requires elastic scaling.</li><li>Message processing time varies, and you want fair distribution.</li><li>You need queue semantics with competing consumers.</li></ul><p><strong>Stick with traditional consumers when:</strong></p><ul><li>You need strict ordering (transactions, session events).</li><li>Building stateful stream processing or aggregations.</li><li>Using Kafka Streams or maintaining partition-local state.</li></ul><h4>Implementing Share Groups in Spring Boot</h4><p>Spring Boot 4.0 makes adoption simple — if you’ve used @KafkaListener, you already know the pattern.</p><p><strong>Basic Configuration</strong></p><pre>@Configuration<br>public class KafkaShareConsumerConfig {    <br>    @Bean<br>    public ShareConsumerFactory&lt;String, String&gt; shareConsumerFactory(KafkaProperties properties) {<br>        Map&lt;String, Object&gt; props = properties.buildConsumerProperties();<br>        // Share Groups don&#39;t support these properties - broker manages delivery<br>        props.remove(&quot;isolation.level&quot;);<br>        props.remove(&quot;auto.offset.reset&quot;);<br>        return new DefaultShareConsumerFactory&lt;&gt;(props);<br>    }<br>    @Bean<br>    public ShareKafkaListenerContainerFactory&lt;?, ?&gt; shareKafkaListenerContainerFactory(<br>            ShareConsumerFactory&lt;?, ?&gt; shareConsumerFactory) {<br>        return new ShareKafkaListenerContainerFactory&lt;&gt;(shareConsumerFactory);<br>    }<br>}</pre><p><strong>Consuming Messages</strong></p><pre>@Component<br>public class DemoConsumer { <br>   @KafkaListener(<br>        topics = &quot;${demo.kafka.topic}&quot;,<br>        containerFactory = &quot;shareKafkaListenerContainerFactory&quot;,<br>        concurrency = &quot;${spring.kafka.listener.concurrency}&quot;<br>    )<br>    public void listen(ConsumerRecord&lt;String, DemoEvent&gt; record) {<br>        log.info(&quot;Processing: {}&quot;, record.value());<br>    }<br>}</pre><p>By default, successful processing implies ACCEPT, and exceptions imply REJECT.</p><h4>Fine-Grained Control with Explicit Acknowledgment</h4><p>For transient failures or business rules that require manual decisions, enable <strong>explicit acknowledgment</strong>:</p><pre>@Bean<br>public ShareConsumerFactory&lt;String, String&gt; explicitShareConsumerFactory(KafkaProperties properties) {<br>    Map&lt;String, Object&gt; props = properties.buildConsumerProperties();<br>    props.put(ConsumerConfig.SHARE_ACKNOWLEDGEMENT_MODE_CONFIG, &quot;explicit&quot;);<br>    return new DefaultShareConsumerFactory&lt;&gt;(props);<br>}</pre><p><strong>Listener with acknowledgment control:</strong></p><pre>@KafkaListener(topics = &quot;demo-topic&quot;, containerFactory = &quot;explicitShareKafkaListenerContainerFactory&quot;)<br>public void processPayment(DemoEvent event, ShareAcknowledgment ack) {<br>    try {<br>        if (!isValid(event)) {<br>            ack.reject(); // permanent failure<br>            return;<br>        }<br>        service.process(event);<br>        ack.acknowledge(); // ACCEPT<br>    } catch (TransientException e) {<br>        ack.release(); // RELEASE - retry later<br>    }<br>}</pre><p>Three acknowledgment types:</p><ul><li>acknowledge() → ACCEPT</li><li>release() → transient failure, retry allowed</li><li>reject() → permanent failure, no retry</li></ul><h4>Scaling with Concurrency</h4><p>Share Groups decouple parallelism from partitions. Spring Boot supports multiple consumer threads per container:</p><pre>spring:<br>  kafka:<br>    listener:<br>      concurrency: 6</pre><p>Each thread acts as an independent consumer within the same share group. Scaling vertically (threads) or horizontally (instances) is additive. Five instances with concurrency 3 = 15 consumers in the same group.</p><p>No rebalancing. No topic partitions reconfiguration.</p><h4>Broker-Managed Retries and Poison Messages</h4><p>Share Groups introduce <strong>broker-managed redelivery</strong>. When a record is acquired, it’s locked for a time window (default 30s). If it’s not acknowledged, the broker returns it to the pool.</p><p>After a configurable number of attempts (group.share.delivery.attempt.limit, default 5), the broker moves the record to <em>Archived</em> state, preventing infinite retries.</p><pre>var maxAttempts = new ConfigEntry(&quot;group.share.delivery.attempt.limit&quot;, &quot;10&quot;);</pre><p>This makes application-level retry logic optional — the broker enforces safety.</p><h4>Testing with Testcontainers</h4><p>Spring Boot 4.0 integrates @ServiceConnection, making Kafka Testcontainers setup seamless:</p><pre>@TestConfiguration(proxyBeanMethods = false)<br>public class TestKafkaConfiguration {<br>    @Bean<br>    @ServiceConnection<br>    public ConfluentKafkaContainer kafkaContainer() {<br>        return new ConfluentKafkaContainer(DockerImageName.parse(&quot;confluentinc/cp-kafka:8.1.0&quot;))<br>            .withEnv(&quot;KAFKA_GROUP_COORDINATOR_REBALANCE_PROTOCOLS&quot;, &quot;classic,consumer,share&quot;)<br>            .withEnv(&quot;KAFKA_SHARE_COORDINATOR_ENABLE&quot;, &quot;true&quot;)<br>            .withEnv(&quot;KAFKA_GROUP_SHARE_ENABLE&quot;, &quot;true&quot;);<br>    }<br>}</pre><pre>@SpringBootApplication<br>public class TestKafkaApplication {<br>    public static void main(String[] args) {<br>        SpringApplication.from(KafkaApplication::main)<br>            .with(TestKafkaConfiguration.class)<br>            .run(args);<br>    }<br>}</pre><p>Run locally with a full-featured Kafka broker — no mocks required.</p><h4>Production Readiness &amp; Compatibility</h4><ul><li><strong>Status:</strong> Early Access (Kafka 4.0), Preview (4.1), GA planned (4.2)</li><li><strong>Version constraint:</strong> Clients and brokers must share the same minor version.</li><li><strong>Limitations:</strong> No message converters or batch listeners yet; unacknowledged records block polls per-thread.</li></ul><p>Share Groups and classic consumer groups can coexist in one cluster, even within the same Spring Boot app.</p><h4>Migration Tips</h4><ul><li>Audit your workloads — identify where ordering doesn’t matter.</li><li>Adjust your acknowledgment strategy (RELEASE vs REJECT).</li><li>Start with non-critical queues and use Testcontainers to validate behavior.</li><li>Monitor archived record metrics to spot poison messages early.</li></ul><h4>Final Takeaways</h4><p>Spring Boot 4.0’s support for Kafka Share Groups redefines parallel message processing. You no longer need to over-partition topics just to scale consumers. Share Groups deliver <strong>record-level distribution, built-in retries and concurrency flexibility</strong> — all with the same @KafkaListener simplicity.</p><p>If your workloads depend on throughput rather than order or if partition scaling has been a headache, this is the feature to watch. As Kafka 4.2 reaches GA, Share Groups will move from experimental to essential.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e7c4e9fc1a1d" width="1" height="1" alt="">

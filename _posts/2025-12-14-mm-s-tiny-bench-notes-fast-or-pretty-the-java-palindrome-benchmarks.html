---
layout: post
title: "[MM’s] Tiny Bench Notes — Fast or Pretty? The Java Palindrome Benchmarks"
canonical_url: https://marconak-matej.medium.com/mms-tiny-bench-notes-fast-or-pretty-the-java-palindrome-benchmarks-1f18b2d74620?source=rss-f1368b7746f7------2
tag:
- palindrome
- jmh
- java
- programming
---

<h3>[MM’s] Tiny Bench Notes — Fast or Pretty? The Java Palindrome Benchmarks</h3><h4>7 Different String-Reversal Algorithms Through JMH to Find the Winner</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/949/1*63wA3nnTx8JbwpaN53V4HA.png" /><figcaption>Fast or Pretty? The Java Palindrome Benchmarks</figcaption></figure><h4>Why Palindromes Are the Perfect Micro-Benchmark</h4><p>Every engineer has that one tiny utility method they’ve written dozens of times: reverse a string, detect vowels, trim whitespace or check for a palindrome.</p><p>It’s deceptively simple work. But these “throwaway” functions often live in performance-sensitive code paths. Over thousands or millions of invocations, the cost adds up.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li>Two-pointer is fastest overall, especially for non-palindromes.</li><li>Recursion is unexpectedly strong for short strings.</li><li>Char arrays win for long palindromes (100+ chars).</li><li>StringBuilder is 4–5× slower, but clean and readable.</li><li>Streams and regex preprocessing are the slowest options.</li></ul><h4>Benchmark Setup</h4><p>All approaches followed the same rules:</p><ul><li>Case-sensitive</li><li>Whitespace-sensitive</li><li>Null/empty values return false</li></ul><p><strong>Test data included:</strong></p><ul><li><strong>Short</strong> (5 chars)</li><li><strong>Medium</strong> (20 chars)</li><li><strong>Long</strong> (100 chars)</li></ul><p>Everything was measured using <strong>JMH 1.37 on Java 25</strong>.</p><p>The benchmarks were run on <strong>OpenJDK 25</strong> (Temurin-25+36) with -Xms1g -Xmx1g -XX:+UseG1GC. It measures the <strong>average execution time per operation in nanoseconds</strong>, running in a <strong>shared benchmark state</strong>, with <strong>2 forks (each doing 1 warmup fork)</strong>, <strong>warming up for 5 iterations of 1 second</strong> each, and then measuring <strong>over 10 iterations of 1 second each</strong>.</p><h4>The Two-Pointer Workhorse</h4><pre>public boolean isPalindrome(String text) {<br>    int left = 0, right = text.length() - 1;<br>    while (left &lt; right) {<br>        if (text.charAt(left) != text.charAt(right)) return false;<br>        left++;<br>        right--;<br>    }<br>    return true;<br>}</pre><p>The classic solution. Tight loop, minimal overhead, excellent branch prediction.</p><p><strong>Highlights:</strong></p><ul><li>Short palindromes: <strong>5.9 ns/op</strong></li><li>Non-palindromes: <strong>~4 ns/op</strong></li><li>Long palindromes: slower at <strong>64.8 ns/op</strong></li></ul><p><strong>Why it works:</strong> The moment characters differ, the loop exits. Non-palindromes benefit the most.</p><h4>Half-String Comparison: The Minimalist Variant</h4><pre>int half = length / 2;<br>for (int i = 0; i &lt; half; i++) {<br>    if (text.charAt(i) != text.charAt(length - 1 - i)) return false;<br>}</pre><p>Checks only half the string — no pointer tracking overhead.</p><p><strong>Highlights:</strong></p><ul><li>Best for medium strings: <strong>9.7 ns/op</strong></li><li>Beats two-pointer for long palindromes too</li></ul><p>Small optimization, big payoff for palindrome-heavy workloads.</p><h4>Recursion: Surprisingly Good</h4><pre>private boolean isPalindromeRecursive(String text, int left, int right) {<br>    if (left &gt;= right) return true;<br>    if (text.charAt(left) != text.charAt(right)) return false;<br>    return isPalindromeRecursive(text, left + 1, right - 1);<br>}</pre><p>Recursion is rarely considered “modern Java”, but here? It’s fast.</p><p><strong>Highlights:</strong></p><ul><li>Short palindromes: <strong>5.3 ns/op</strong> (faster than two-pointer!)</li><li>Medium non-palindromes: <strong>3.9 ns/op</strong> (fastest!)</li></ul><p>Don’t use this on very long strings — stack overflow risk.</p><h4>Char Arrays: Pay the Copy Once</h4><pre>char[] chars = text.toCharArray();<br>int left = 0, right = chars.length - 1;<br>while (left &lt; right) {<br>    if (chars[left] != chars[right]) return false;<br>    left++; right--;<br>}</pre><p>Copying the string costs time, but once you have the char[], access is extremely fast.</p><p><strong>Highlights:</strong></p><ul><li>Long palindromes: <strong>31.6 ns/op</strong> (best in class)</li><li>Short strings: slower due to array creation</li></ul><h4>StringBuilder Reverse: The “Readable” Option</h4><pre>String reversed = new StringBuilder(text).reverse().toString();<br>return text.equals(reversed);</pre><p>The most “Java developer” solution.</p><p><strong>Benchmarks:</strong></p><ul><li>Short strings: <strong>27 ns/op</strong></li><li>Long strings: <strong>37–42 ns/op</strong></li></ul><p>Not terrible, not great. Predictable overhead, but extremely readable.</p><h4>Stream API: Convenience vs Cost</h4><pre>return IntStream.range(0, length / 2)<br>    .allMatch(i -&gt; text.charAt(i) == text.charAt(length - 1 - i));</pre><p>Modern, expressive and slow.</p><p><strong>Benchmarks:</strong></p><ul><li>Medium palindromes: <strong>87.7 ns/op</strong></li><li>Long palindromes: <strong>404 ns/op</strong></li></ul><h4>The Insight: Early Exit Wins</h4><p>Most algorithms perform extremely well on non-palindromes, because they detect the mismatch at the first or second character.</p><p>This yields:</p><ul><li><strong>4 ns/op</strong> for pointer-based methods</li><li><strong>10× slower</strong> for actual palindromes (which require full traversal)</li></ul><p>If your workload is mostly non-palindromic strings, almost anything performs fine.</p><h4>Recommended Algorithms (Based on Input Characteristics)</h4><p><strong>Use Two-Pointer If…</strong></p><ul><li>Input size varies</li><li>You want the best overall performance</li><li>You expect many non-palindromes</li></ul><p><strong>Use Recursion If…</strong></p><ul><li>Inputs are short</li><li>Code clarity matters</li><li>Stack depth is predictable</li></ul><p><strong>Use StringBuilder If…</strong></p><ul><li>Readability &gt; raw performance</li></ul><h4>Final Takeaways</h4><ul><li>Even trivial algorithms deserve benchmarking — intuition is rarely enough.</li><li>Early exit has a dominant effect on actual performance.</li><li>There is no single “fastest” implementation, workload drives the optimal choice.</li><li>Pointer-based approaches remain the most reliable performers in Java.</li></ul><p>You can find all the code on <a href="https://github.com/marconak-matej/tiny-functions-bench">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1f18b2d74620" width="1" height="1" alt="">

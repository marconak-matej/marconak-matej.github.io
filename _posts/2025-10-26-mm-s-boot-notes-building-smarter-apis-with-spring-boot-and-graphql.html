---
layout: post
title: "[MM’s] Boot Notes — Building Smarter APIs with Spring Boot and GraphQL"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-building-smarter-apis-with-spring-boot-and-graphql-0a7d5032b332?source=rss-f1368b7746f7------2
tag:
- java
- graphql
- spring-boot
- programming
---

<h3>[MM’s] Boot Notes — Building Smarter APIs with Spring Boot and GraphQL</h3><h4>How GraphQL simplifies data fetching and API design for modern Spring apps</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PvdGwlJETHj4qEiBzCShaQ.jpeg" /><figcaption>Building Smarter APIs with Spring Boot and GraphQL</figcaption></figure><p>Every backend developer knows the “data dilemma”: <strong>REST</strong> gives you too much or too little, <strong>SOAP</strong> gives you XML headaches and <strong>gRPC</strong> gives you performance with rigidity.<br><strong>GraphQL</strong> changes the game — letting clients ask <em>exactly</em> for what they need, nothing more, nothing less.<br>With <strong>Spring Boot’s</strong> native <strong>GraphQL</strong> starter, you can now build these smarter APIs with zero boilerplate.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li><strong>Spring Boot</strong> with native <strong>GraphQL support</strong> via spring-boot-starter-graphql.</li><li><strong>Schema-first development</strong>: Define types and operations, then auto-generate Java classes.</li><li><strong>GraphiQL UI</strong>: Explore and test your API live.</li><li><strong>Annotation-based mappings</strong>: Use @QueryMapping and @MutationMapping</li><li><strong>Built-in error handling</strong> and <strong>type safety</strong> make <strong>GraphQL</strong> a natural fit for Spring developers.</li></ul><h4>GraphQL’s Rise in the Spring Ecosystem</h4><p>The Spring team has aligned GraphQL’s flexibility with its dependency injection and controller paradigms. With Spring Boot, developers get:</p><ul><li>A single /graphql endpoint for all operations.</li><li>Integrated <strong>GraphiQL</strong> web UI for live queries.</li><li>Full <strong>schema inspection</strong> and <strong>observability</strong> support.</li><li>Out-of-the-box <strong>code generation</strong> for schema-defined types.</li></ul><p><strong>GraphQL</strong> fits perfectly into modern architectures where clients — especially front-end and mobile apps — demand selective data retrieval and predictable APIs.</p><h4>When to Choose GraphQL</h4><p><strong>Best suited for:</strong></p><ul><li>Mobile apps with limited bandwidth (fetch only needed fields)</li><li>Complex UIs with nested data requirements</li><li>Multiple clients with different data needs</li><li>Rapid frontend iteration without backend changes</li></ul><p><strong>Consider REST/gRPC when:</strong></p><ul><li>Simple CRUD operations with fixed data structures</li><li>High-throughput microservice-to-microservice communication</li><li>File uploads or binary data transfer</li><li>Strict RESTful caching requirements</li></ul><h4>Schema-First, the Spring Way</h4><p>At the heart of every GraphQL API lies the schema. In Spring Boot, you simply drop a .graphqls file into src/main/resources/graphql/:</p><pre>type Query {<br>    product(id: ID!): Product!<br>    products(page: Int = 0, size: Int = 10): ProductPage!<br>}<br><br>type Mutation {<br>    createProduct(input: CreateProductInput!): CreateProductPayload!<br>    updateProduct(id: ID!, input: UpdateProductInput!): UpdateProductPayload!<br>    deleteProduct(id: ID!): DeleteProductPayload!<br>}<br><br>type Product {<br>    id: ID!<br>    name: String!<br>    data: ProductData<br>}<br><br>type ProductData {<br>    color: String<br>    capacity: String<br>    generation: String<br>}<br><br>...</pre><p>Spring Boot detects and wires these definitions into the <strong>GraphQL</strong> engine.</p><h4>Generating Java Code from the Schema</h4><p>Instead of manually creating DTOs, you can integrate a code generation plugin like the popular graphqlcodegen-maven-plugin to create them automatically from the schema.</p><pre>&lt;plugin&gt;<br>  &lt;groupId&gt;io.github.deweyjose&lt;/groupId&gt;<br>  &lt;artifactId&gt;graphqlcodegen-maven-plugin&lt;/artifactId&gt;<br>  &lt;version&gt;${graphql-codegen-maven-plugin.version}&lt;/version&gt;<br>  &lt;executions&gt;<br>    &lt;execution&gt;<br>      &lt;goals&gt;&lt;goal&gt;generate&lt;/goal&gt;&lt;/goals&gt;<br>      &lt;configuration&gt;<br>        &lt;schemaPaths&gt;&lt;param&gt;src/main/resources/graphql&lt;/param&gt;&lt;/schemaPaths&gt;<br>        &lt;packageName&gt;io.github.mm.graphql.product.graphql.model&lt;/packageName&gt;<br>      &lt;/configuration&gt;<br>    &lt;/execution&gt;<br>  &lt;/executions&gt;<br>&lt;/plugin&gt;</pre><p>This ensures <strong>type safety</strong> and <strong>consistent contract alignment</strong> between schema and Java code.</p><h4>Defining Your API Logic</h4><p><strong>Spring</strong> makes it straightforward to bind <strong>GraphQL</strong> fields to methods using annotations:</p><pre>@Controller<br>public class ProductApi {<br>  // ....<br><br>  @QueryMapping<br>  public Product product(@Argument String id) {<br>      return service.getProductById(id);<br>  }<br>  @MutationMapping<br>  public CreateProductPayload createProduct(@Argument CreateProductInput input) {<br>      return service.createProduct(input);<br>  }<br>}</pre><p>Here:</p><ul><li>@QueryMapping corresponds to <strong>GraphQL</strong>’s Query operations.</li><li>@MutationMapping handles data modification.</li><li>@Argument extracts query parameters from the <strong>GraphQL</strong> request.</li></ul><p>This declarative style mirrors the familiar <strong>Spring MVC</strong> model while providing <strong>GraphQL</strong>’s precision.</p><h4>Built-In GraphiQL UI Explorer</h4><p>Enable <strong>GraphiQL</strong> in application.properties:</p><pre>spring.graphql.graphiql.enabled=true<br>spring.graphql.graphiql.path=/graphiql</pre><p>Now visit <a href="http://localhost:8080/graphiql"><strong>http://localhost:8080/graphiql</strong></a> to write and execute queries interactively. You can explore your schema, run mutations and see live JSON responses — all without external tools.</p><p><strong>Example query:</strong></p><pre>query {<br>  products(page: 0, size: 10) {<br>    content {<br>      id<br>      name<br>      data {<br>        color<br>        capacity<br>        generation<br>      }<br>    }<br>    totalElements<br>    totalPages<br>    pageNumber<br>    pageSize<br>  }<br>}</pre><h4>Error Handling That Feels Like Spring</h4><p>Spring integrates seamlessly with <strong>GraphQL</strong>’s error model via a DataFetcherExceptionResolver:</p><pre>@Component<br>public class GraphQlExceptionHandler extends DataFetcherExceptionResolverAdapter {<br>  @Override<br>  protected GraphQLError resolveToSingleError(Throwable ex, DataFetchingEnvironment env) {<br>      if (ex instanceof NotFoundException nf) {<br>          return GraphqlErrorBuilder.newError()<br>              .errorType(ErrorType.NOT_FOUND)<br>              .message(nf.getMessage())<br>              .path(env.getExecutionStepInfo().getPath())<br>              .build();<br>      }<br>      return null;<br>  }<br>}</pre><p>The result? Clean, structured error responses such as:</p><pre>{<br>  &quot;errors&quot;: [<br>    {<br>      &quot;message&quot;: &quot;Product not found with id: 123&quot;,<br>      &quot;path&quot;: [&quot;product&quot;],<br>      &quot;extensions&quot;: { &quot;errorType&quot;: &quot;NOT_FOUND&quot; }<br>    }<br>  ]<br>}</pre><p>Or more modern alternative:</p><pre>@ControllerAdvice<br>public class GraphQlExceptionHandler {<br><br>    @GraphQlExceptionHandler<br>    public GraphQLError handleNotFoundException(NotFoundException ex, DataFetchingEnvironment env) {<br>        return GraphqlErrorBuilder.newError()<br>            .errorType(ErrorType.NOT_FOUND)<br>            .message(ex.getMessage())<br>            .path(env.getExecutionStepInfo().getPath())<br>            .build();<br>    }<br><br>    // ... other exception handlers<br>}</pre><h4>Common Pitfalls to Avoid</h4><p><strong>1. N+1 Query Problem</strong> ✗ Fetching related data without batching — Use DataLoader pattern for batch fetching</p><p><strong>2. Over-exposing Data</strong> ✗ Returning all fields from database entities — Use dedicated GraphQL types that expose only necessary fields</p><p><strong>3. Missing Error Handling</strong> ✗ Generic exceptions that leak implementation details — Structured errors with proper error types</p><p><strong>4. No Query Complexity Limits</strong> ✗ Allowing arbitrarily deep/expensive queries — Implement depth and complexity instrumentation</p><p><strong>5. Forgetting Nullability</strong> ✗ Making everything non-null with ! in schema — Use nullable by default, mark required fields explicitly</p><h4>Testing Your GraphQL Endpoints</h4><p>Spring’s GraphQlTester simplifies automated testing:</p><pre>@SpringBootTest<br>@AutoConfigureGraphQlTester<br>class ProductApiTests {<br>  @Autowired<br>  GraphQlTester tester;<br>  @Test<br>  void shouldCreateAndFetchProduct() {<br>    tester.document(&quot;&quot;&quot;<br>      mutation {<br>        createProduct(input: { name: &quot;MacBook Air&quot;, data: { color: &quot;Silver&quot; } }) {<br>          product { id name }<br>        }<br>      }<br>    &quot;&quot;&quot;).execute().path(&quot;createProduct.product.name&quot;).entity(String.class).isEqualTo(&quot;MacBook Air&quot;);<br>  }<br>}</pre><p>This lets you verify your <strong>GraphQL</strong> operations end-to-end without spinning up a frontend or using Postman — perfect for CI pipelines.</p><h4>Comparing GraphQL with REST, SOAP and gRPC</h4><p>Spring now supports multiple paradigms for APIs. Here’s how they differ conceptually:</p><p><strong>SOAP</strong></p><ul><li>XML-based, verbose, and heavy on contracts.</li><li>Great for enterprise legacy systems, but not flexible for modern front ends.</li></ul><p><strong>REST</strong></p><ul><li>Simpler than SOAP; each resource exposed via endpoints.</li><li>Suffers from over-fetching (too much data) or under-fetching (multiple calls).</li></ul><p><strong>gRPC</strong></p><ul><li>Binary protocol ideal for microservices communication.</li><li>Efficient, but less human-friendly.</li></ul><p><strong>GraphQL</strong></p><ul><li>One endpoint, declarative queries, and introspection built-in.</li><li>Clients choose exactly what data to fetch — ideal for UI-driven applications.</li></ul><p>In the Spring ecosystem, <strong>GraphQL</strong> doesn’t replace <strong>REST</strong> or <strong>gRPC</strong> — it <strong>complements them</strong>. Use <strong>GraphQL</strong> when clients demand flexibility and rich object graphs; use <strong>REST</strong> or <strong>gRPC</strong> for fixed contracts or high-performance internal APIs.</p><h4>Final Takeaways</h4><p><strong>GraphQL</strong> isn’t just another API buzzword — it’s a shift toward <em>client-driven data exchange</em>. With <strong>Spring Boot</strong> native integration, developers can build query-driven APIs that feel as expressive as <strong>SQL</strong>, but run with <strong>Spring Boot </strong>simplicity.</p><p>Whether you’re designing APIs for mobile clients or modern dashboards, <strong>GraphQL</strong> brings <strong>precision</strong>, <strong>type safety</strong> and <strong>developer joy</strong> to the Spring ecosystem.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=0a7d5032b332" width="1" height="1" alt="">

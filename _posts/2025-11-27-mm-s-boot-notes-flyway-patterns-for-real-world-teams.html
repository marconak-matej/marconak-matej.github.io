---
layout: post
title: "[MM’s] Boot Notes — Flyway Patterns for Real-World Teams"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-flyway-patterns-for-real-world-teams-9ca843eba540?source=rss-f1368b7746f7------2
tag:
- spring-framework
- flyway
- spring-boot
- data-migration
- java
---

<h3>[MM’s] Boot Notes — Flyway Patterns for Real-World Teams</h3><h4>Database Migrations Done Right in Spring Boot</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*18KhAFNeMNCJBxuD2TzOhw.png" /><figcaption>Database Migrations Done Right in Spring Boot</figcaption></figure><p>If you’re building Spring Boot applications in 2025, database migrations are no longer a “junior dev concern.” They’re foundational infrastructure code and if you’re using <strong>Spring Boot</strong>, Flyway becomes an even more important part of making your database evolution boring, predictable and safe.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li>Flyway + Spring Boot gives you zero-config migration setup with profile-based deployment strategies.</li><li>Baseline migrations solve the “200 SQL files, 10-minute startup” problem.</li><li>Separate app deployment from database migration in production.</li><li>Test everything with Testcontainers.</li></ul><h4>Why This Topic Matters Right Now</h4><p>Spring Boot introduced the most polished Flyway integration yet. Combined with Java 21+, record-heavy domain models and Testcontainers-native testing, migrations are finally becoming something you can build discipline around.</p><p>But the real reason this matters?</p><blockquote><strong><em>Your application code changes weekly. Your database schema survives for years.</em></strong></blockquote><p>The cost of getting a migration wrong isn’t a failed build — it’s corrupted production data, rollback nightmares…</p><p>Let’s make migrations boring, predictable and a first-class citizen in your Spring Boot workflow.</p><h4>Flyway + Spring Boot: A Smooth Start</h4><p>Spring Boot gives you plug-and-play Flyway support out of the box. Add two dependencies:</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-flyway&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;<br>    &lt;artifactId&gt;flyway-database-postgresql&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p><strong>Configure it:</strong></p><pre>spring:<br>  datasource:<br>    url: jdbc:postgresql://localhost:5432/mydb<br>    username: dbuser<br>    password: dbpass<br>  flyway:<br>    locations: classpath:db/migration<br>    validate-on-migrate: true<br>    clean-disabled: true<br>    schemas: flyway,dbo<br>    default-schema: flyway</pre><p>And drop your migrations into:</p><pre>src/main/resources/db/migration</pre><p>Names matter:</p><pre>V1__init.sql<br>V2.1__add_users_table.sql<br>V3__create_orders.sql</pre><p>Start your app → Flyway runs → done. This is already great, but it’s just the beginning.</p><h4>The Real-World Problems Every Team Hits</h4><p><strong>Problem 1: The ORM Trap</strong></p><p>You start with:</p><pre>spring.jpa.hibernate.ddl-auto=update</pre><p>It works on your laptop. Then someone renames a JPA field. Hibernate doesn’t rename the column — it silently creates a new one. Now your database has zombie columns.</p><p><strong>Problem 2: Someone Modified a Past Migration</strong></p><p>Flyway checksum mismatch. Your pipeline refuses to deploy. Debugging begins: “Did we fix the file or create a new migration?” (This should never be a question.)</p><p><strong>Problem 3: Startup Time Crawl</strong></p><p>Your CI runs 217 migrations every time Testcontainers boots a database. The pipeline slows. Developers skip writing integration tests because they take too long.</p><p><strong>Problem 4: Race Conditions in Distributed Systems</strong></p><p>When your Kubernetes deployment scales up, 10 pods may try to run migrations at once. Flyway locks help — but running migrations at startup is still not ideal.</p><h4>Profile-Based Migration Strategy: The Most Underrated Pattern</h4><p>In <strong>development</strong>, you want Flyway to auto-apply migrations. In <strong>production</strong>, you absolutely do NOT want Flyway to run changes automatically during app startup. <br>When a Kubernetes pod restarts during a deployment, it shouldn’t block startup waiting for a 5-minute schema migration. Worse, if <br>multiple pods start simultaneously, they’ll race for the migration <br>lock, causing cascading delays.</p><p><strong>Here’s the pattern every team should use:</strong></p><pre>@Configuration<br>public class FlywayConfig {<br>    @Bean<br>    @Profile(&quot;!prod&quot;)<br>    public FlywayMigrationStrategy migrateStrategy() {<br>        return Flyway::migrate;<br>    }<br>    @Bean<br>    @Profile(&quot;prod&quot;)<br>    public FlywayMigrationStrategy validateStrategy() {<br>        return Flyway::validate;<br>    }<br>}</pre><p><strong>What this gives you:</strong></p><ul><li><strong>Dev</strong> → Migrations run automatically, nice feedback loop.</li><li><strong>Prod</strong> → Flyway <em>validates</em> but does not migrate.</li></ul><p><strong>Production workflow:</strong></p><pre># Step 1 — Run schema migration as a separate deployment step<br>./mvnw flyway:migrate -Dflyway.configFiles=flyway-prod.conf</pre><p>This decouples app deploy from schema changes — a must for blue-green and zero-downtime rollouts.</p><h4>Baseline Migrations: When You Have Too Many SQL Files</h4><p>After months or years of development, you accumulate migrations:</p><pre>V1__init.sql<br>V2__users.sql<br>V3__orders.sql<br>...<br>V214__optimizations.sql</pre><p><strong>The problem</strong>: After accumulating 214 migrations over 2 years, every <br>fresh database (CI runs, new developer onboarding, Testcontainers <br>tests) replays all 214 scripts sequentially.</p><p><strong>The solution</strong>: Create a baseline migration that’s a snapshot of your <br>current schema. For existing databases, Flyway marks it as “already <br>applied.” For fresh databases, it runs this single comprehensive <br>script instead of 214 incremental ones.</p><p><strong>The fix: </strong>a baseline migration.</p><pre>V1__init.sql<br>...<br>V214__whatever.sql<br>B214__baseline.sql   ← a single script representing current schema<br>V215__add_tags.sql</pre><p><strong>Result</strong>: Fresh startup time drops from ~10 minutes to ~45 seconds.</p><h4>Multi-Schema Migration: Separating Your Metadata</h4><p>A good production practice is keeping Flyway’s own tables out of your application schema:</p><pre>spring:<br>  flyway:<br>    schemas: flyway,dbo<br>    default-schema: flyway<br>    create-schemas: true</pre><p>What this means:</p><ul><li>flyway_schema_history lives in flyway</li><li>Your applications tables live in dbo</li></ul><p>Your application user only needs permissions for dbo. Your migration runner user needs elevated rights for both. Security + clean boundaries.</p><h4>Writing Safe, Backward-Compatible Migrations</h4><p>This is where large teams often fall over.</p><p>If you’re deploying with rolling updates, your new app version must work with the <em>old</em> schema — and your old app version must work with the <em>new</em> schema.</p><p>Follow this <strong>four-phase approach</strong>:</p><p><strong>Phase 1 — Additive, safe changes</strong></p><p>Add new columns, nullable or with defaults:</p><pre>ALTER TABLE products ADD COLUMN status VARCHAR(20) DEFAULT &#39;ACTIVE&#39;;</pre><p><strong>Phase 2 — Dual writes</strong></p><p>Write to both the old and new column (via app logic or triggers).</p><p><strong>Phase 3 — Switch reads</strong></p><p>App starts reading from the new column.</p><p><strong>Phase 4 — Cleanup</strong></p><p>Drop old columns after verifying no consumers rely on them.</p><p><strong>Golden rules:</strong></p><ul><li>Never rename columns, add new ones.</li><li>Never drop columns until multiple releases have passed.</li><li>Avoid destructive changes during peak traffic windows.</li><li>Use views to smooth transitions when needed.</li></ul><h4>Transactional DDL Isn’t Always Available</h4><p>PostgreSQL supports transactional DDL → good. MySQL, MariaDB and some Oracles → not so much.</p><pre>CREATE TABLE employees (...);<br>INSERT INTO employees VALUES (...);  -- fails</pre><p>Postgres → everything rolls back. MySQL → table is created, insert fails, inconsistent state. Always test migrations in the <strong>same database engine as prod</strong>.</p><h4>Testing Migrations with Testcontainers</h4><p>Treat migrations as code. Test them.</p><p><strong>Example configuration:</strong></p><pre>@TestConfiguration(proxyBeanMethods = false)<br>public class TestcontainersConfig {<br>    @Bean<br>    @ServiceConnection<br>    public PostgreSQLContainer&lt;?&gt; postgres() {<br>        return new PostgreSQLContainer&lt;&gt;(&quot;postgres:16-alpine&quot;)<br>                .withDatabaseName(&quot;product&quot;)<br>                .withUsername(&quot;user&quot;)<br>                .withPassword(&quot;pass123&quot;);<br>    }<br>}</pre><p><strong>Verify migration success:</strong></p><pre>@SpringBootTest<br>@Import(TestcontainersConfig.class)<br>class FlywayMigrationTest {<br>    @Autowired<br>    Flyway flyway;<br>    @Test<br>    void allMigrationsShouldApply() {<br>        var info = flyway.info();<br>        assertThat(info.all())<br>            .allMatch(m -&gt; m.getState().isApplied());<br>    }<br>}</pre><p>And test schema behavior with repositories. Testing migrations avoids production surprises — the only kind of surprises nobody wants.</p><h4>Comparing Flyway</h4><p><strong>Flyway</strong></p><ul><li>Simple versioning</li><li>Great Spring Boot integration</li><li>Easy to reason about</li><li>Large ecosystem</li></ul><p>Best for 90% of JVM applications.</p><p><strong>Liquibase</strong></p><ul><li>Rollback support</li><li>XML/JSON/YAML changelogs</li><li>Conditional logic</li></ul><p>Best for complex enterprise environments.</p><p><strong>Hibernate DDL Auto</strong></p><p>Good for prototypes; never for production.</p><p><strong>schema.sql + data.sql</strong></p><p>Fine for demos, not for real apps. Will be removed eventually.</p><h4>Final Takeaways</h4><p>Flyway isn’t just a migration tool — it’s a foundation for safe, repeatable, controlled database evolution. When you combine Spring Boot’s improved integration, baseline strategies, profile-based deployment and Testcontainers for validation, migrations stop being operational headaches.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9ca843eba540" width="1" height="1" alt="">

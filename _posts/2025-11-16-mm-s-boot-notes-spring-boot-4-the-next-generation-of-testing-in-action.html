---
layout: post
title: "[MMâ€™s] Boot Notesâ€Šâ€”â€ŠSpring Boot 4: The Next Generation of Testing in Action"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-spring-boot-4-the-next-generation-of-testing-in-action-9bf774868237?source=rss-f1368b7746f7------2
tag:
- spring-boot
- junit
- programming
- java
---

<h3>[MMâ€™s] Boot Notesâ€Šâ€”â€ŠSpring Boot 4: The Next Generation of Testing inÂ Action</h3><h4>The Next Generation: RestTestClient Unifies HTTP, Context Pausing Accelerates CI and Testcontainers Goes Zero-Config.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*iqUs8m_F_yuHBmLL2vbqOQ.png" /><figcaption>Spring Boot 4: The Next Generation of Testing inÂ Action</figcaption></figure><p>Testing in Spring has always evolved with the Java ecosystemâ€Šâ€”â€Šfrom XML-driven runners to annotation-based contexts. With <strong>Spring Framework 7</strong> and <strong>Spring Boot 4</strong>, the testing model takes another leap forward. These releases retire <strong>JUnit</strong> 4, unify HTTP testing with a single client API, optimize context reuse and deeply integrate with <strong>Testcontainers</strong> (including the latest 2.x release) for infrastructure testing. The result: tests that are faster, cleaner, and ready for the modernÂ JVM.</p><h4>âš¡ <strong>TL;DR (QuickÂ Recap)</strong></h4><ul><li><strong>JUnit 4 â†’ JUnitÂ 6</strong></li><li><strong>RestTestClient:</strong> one fluent API for both MockMvc-backed and live-server tests, now with AssertJÂ support.</li><li><strong>Context pausing:</strong> Spring 7 suspends background threads between classes, significantly reducing suite execution time.</li><li><strong>Nested tests:</strong> consistent dependency injection at allÂ levels.</li><li><strong>Prototype bean mocking:</strong> @MockitoBean finally supports non-singleton scopes.</li><li><strong>Application events, ServiceConnectionÂ â€¦</strong></li></ul><h4>Why Now</h4><p>Spring 7 aligns with <strong>Jakarta EE 10</strong>, <strong>Java 21</strong>, and the new <strong>JUnit 6</strong> architecture. The testing model that carried us through the last decade no longer fits todayâ€™s cloud-native, CI-driven pipelines. The Spring team used this release to clean up legacy layers, simplify APIs and ensure tests behave the same way in memory, on a container or in production.</p><h4>Goodbye JUnit 4, Hello JUnitÂ 6</h4><p>For years, a Spring test looked likeÂ this:</p><pre>@RunWith(SpringRunner.class)<br>public class MyTest {<br>    @Autowired MyService service;<br>    @Test<br>    public void testSomething() { ... }<br>}</pre><p>That runner is now <strong>deprecated</strong>. Spring 7 fully embraces JUnit 6â€™sÂ API.</p><p><strong>Why itÂ matters</strong></p><p>JUnit 6 isnâ€™t a cosmetic upgradeâ€Šâ€”â€Šitâ€™s a redesign thatÂ unlocks:</p><ul><li>Parameter injection for test and lifecycle methods</li><li>Native support for @NestedÂ tests</li><li>Conditional execution (@EnabledOnOs, @EnabledIf)</li><li>A clean extension model instead of runners/rules</li></ul><p>If youâ€™re still on JUnit 4, migration isnâ€™t optionalâ€Šâ€”â€Šbut itâ€™s straightforward, and the benefits are immediate.</p><h4>RestTestClient: One API to Rule ThemÂ All</h4><p>Testing HTTP endpoints used to mean choosing between three overlapping tools:</p><ul><li><strong>MockMvc</strong>â€Šâ€”â€Šfast butÂ verbose</li><li><strong>TestRestTemplate</strong>â€Šâ€”â€Šlive serverÂ only</li><li><strong>WebTestClient</strong>â€Šâ€”â€ŠreactiveÂ only</li></ul><p><strong>RestTestClient</strong> in Spring Boot 4 replaces them with a unified API that works everywhere.</p><p><strong>MockMvc-backed example:</strong></p><pre>@WebMvcTest(ProductApi.class)<br>@AutoConfigureRestTestClient<br>class ProductApiMockMvcTest {<br>    @MockitoBean ProductService service;<br>    @Autowired RestTestClient client;<br>    @Test<br>    void shouldGetProductById() {<br>        given(service.getProductById(1L))<br>            .willReturn(new Product(1L, &quot;Laptop&quot;, 999.99));<br>        var result = client.get()<br>            .uri(&quot;/api/products/{id}&quot;, 1L)<br>            .exchange()<br>            .expectStatus().isOk()<br>            .returnResult(Product.class);<br>        assertThat(result.getResponseBody().name()).isEqualTo(&quot;Laptop&quot;);<br>        verify(service).getProductById(1L);<br>    }<br>}</pre><p>Switch to a <strong>live server</strong> by changing one annotation:</p><pre>@SpringBootTest(webEnvironment = RANDOM_PORT)<br>@AutoConfigureRestTestClient<br>class ProductApiLiveTest {<br>    @Autowired RestTestClient client;<br>    @Test<br>    void shouldCreateProduct() {<br>        var req = new CreateProductRequest(&quot;Laptop&quot;, 999.99);<br>        var result = client.post()<br>            .uri(&quot;/api/products&quot;)<br>            .body(req)<br>            .exchange()<br>            .expectStatus().isCreated()<br>            .returnResult(Product.class);<br>        assertThat(result.getResponseBody()).isNotNull();<br>    }<br>}</pre><p>Same client, sameÂ API.</p><p>ðŸ’¡ <strong>Bonus:</strong> RestTestClient now speaks AssertJ fluentlyâ€Šâ€”â€Šno more Hamcrest boilerplate:</p><pre>assertThat(result).hasStatusOk()<br>                  .hasContentTypeCompatibleWith(MediaType.APPLICATION_JSON);</pre><h4>Context Pausing: Speed Through Efficiency</h4><p>Running dozens of Spring tests often left background threads chewing CPU even when idle.<br> Spring 7 introduces <strong>automatic contextÂ pausing</strong>:</p><ol><li>A test class finishes.</li><li>The shared ApplicationContext is paused â€“ all SmartLifecycle beansÂ stop.</li><li>When the next test needs that context, it resumes instantly.</li></ol><p>Opt-in is as simple as implementing isPauseable() â†’ true in your SmartLifecycle components. Providing substantial performance improvements in testÂ suites</p><h4>Nested Tests That ActuallyÂ Work</h4><p>@Nested tests make suites readable, but injection in nested contexts used to be inconsistent.<br> Spring 7 fixes thatâ€Šâ€”â€Šconstructor, field, and parameter injection now work across all nestingÂ levels:</p><pre>@SpringBootTest<br>class ProductServiceNestedTest {<br>    @Autowired ProductService service;<br>    @Nested<br>    class WhenProductExists {<br>        Product product;<br>        @BeforeEach<br>        void create(@Autowired ProductService s) {<br>            product = s.createProduct(&quot;Laptop&quot;, 999.99);<br>        }<br>        @Test<br>        void shouldFindById(@Autowired ProductService s) {<br>            assertThat(s.getProductById(product.id()).name())<br>                .isEqualTo(&quot;Laptop&quot;);<br>        }<br>    }<br>}</pre><p>Everythingâ€Šâ€”â€Š@BeforeEach, @AfterEach, and @Testâ€Šâ€”â€Šnow supports parameter injection reliably.</p><h4>Mocking Prototype Beans with @MockitoBean</h4><p>For years, @MockitoBean worked only for singleton beans.<br> Spring 7 removes that limitation:</p><pre>@SpringBootTest<br>class PrototypeBeanTest {<br>    @MockitoBean RequestIdGenerator generator; // prototype bean<br>    @Autowired OrderService service;<br>    @Test<br>    void shouldMockPrototype() {<br>        given(generator.generate()).willReturn(&quot;MOCK-ID&quot;);<br>        var order = service.createOrder(&quot;CUST-1&quot;);<br>        assertThat(order.requestId()).isEqualTo(&quot;MOCK-ID&quot;);<br>    }<br>}</pre><p>Behind the scenes, Spring treats the mock as a singleton for test scopeâ€Šâ€”â€Šperfect for verifying interactions without touching real scopeÂ logic.</p><h4>ApplicationEvents: Simpler Event-Driven Testing</h4><p>No more manual listeners or wiring. Just annotate andÂ inject:</p><pre>@SpringBootTest<br>@RecordApplicationEvents<br>class OrderEventsTest {<br>    @Autowired OrderService service;<br>    @Test<br>    void shouldPublishOrderCreated(ApplicationEvents events) {<br>        var order = service.createOrder(&quot;CUST-1&quot;);<br>        var created = events.stream(OrderCreatedEvent.class).findFirst().orElseThrow();<br>        assertThat(created.orderId()).isEqualTo(order.id());<br>    }<br>}</pre><p>Each test method gets a fresh ApplicationEvents instance. Itâ€™s lightweight and perfectly scoped.</p><h4>Testcontainers + @ServiceConnection = Zero Boilerplate</h4><p>The <strong>@ServiceConnection</strong> annotation eliminates repetitive property plumbing also using a <strong>Testcontainers</strong> (including the latest 2.x release):</p><pre>@SpringBootTest<br>@Testcontainers<br>class PostgresContainerTest {<br>    @Container<br>    @ServiceConnection<br>    // org.testcontainers.postgresql.PostgreSQLContainer - Testcontainers 2.0<br>    static PostgreSQLContainer postgres =<br>        new PostgreSQLContainer(&quot;postgres:16-alpine&quot;);<br>    @Autowired JdbcClient client;<br>    @Test<br>    void shouldConnect() {<br>        assertThat(postgres.isRunning()).isTrue();<br>        client.sql(&quot;SELECT 1&quot;).query(Integer.class).single();<br>    }<br>}</pre><p>Spring Boot detects the container and automatically configures the DataSource. It works out of the box for Postgres, MySQL, MongoDB, Redis, Kafka, RabbitMQ, and any container with a matching auto-configuration.</p><h3>Final Takeaways</h3><p>Spring Boot 4 and Spring Framework 7 mark a <strong>turning point</strong> in how we test Spring applications:</p><ul><li><strong>Modern by default:</strong> JUnit 6 and Java 21 baseline.</li><li><strong>Unified testing API:</strong> RestTestClient for all web scenarios.</li><li><strong>Smarter execution:</strong> context pausing and consistent injection.</li><li><strong>Less boilerplate:</strong> ServiceConnection and MockitoBean enhancements.</li></ul><p>If your project still runs JUnit 4 tests, plan your migration soonâ€Šâ€”â€Šthe payoff is immediate: faster builds, cleaner code, and tests that mirror production behavior.</p><p>You can find all the code onÂ <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9bf774868237" width="1" height="1" alt="">

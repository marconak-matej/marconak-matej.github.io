---
layout: post
title: "[MM’s] Boot Notes — Spring Boot Annotations You Use Every Day"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-spring-boot-annotations-you-use-every-day-2aaca52762d9?source=rss-f1368b7746f7------2
tag:
- spring-boot
- java
- backend-development
- programming
- spring-annotation
---

<h4>Spring Boot’s Core, Web, Data, Messaging and Testing Annotations</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/970/1*UsNiEy3z2qnwjBXpn7dBmg.png" /><figcaption>Spring Boot Annotations You Use Every Day</figcaption></figure><p>At first glance, Spring Boot appears deceptively simple.</p><p>You add @SpringBootApplication, write a controller and suddenly your API is live. But after building a few services, you realize something: annotations <em>express</em> architectural boundaries — they don’t replace architecture..</p><p>They define how beans are created, how HTTP requests are mapped, how transactions behave, how validation is triggered and even how your tests start up.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li>Spring Boot annotations map directly to architectural layers.</li><li>Constructor injection usually needs no @Autowired since Spring 4.3.</li><li>Web, Data, Messaging, Validation and Testing each have their own core annotation set.</li><li>Clean grouping improves design clarity and maintainability.</li></ul><h4>Core / Application Setup</h4><p>These annotations bootstrap and structure your application.</p><p><strong>@SpringBootApplication</strong> The heart of every Boot app.</p><p>It combines:</p><ul><li>@Configuration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><pre>@SpringBootApplication<br>public class Application {<br>    public static void main(String[] args) {<br>        SpringApplication.run(Application.class, args);<br>    }<br>}</pre><p>This single annotation activates auto-configuration and component scanning.</p><p><strong>Stereotypes: </strong><strong>@Component, </strong><strong>@Service, </strong><strong>@Repository</strong> They mark classes as Spring-managed beans.</p><ul><li>@Component – generic bean</li><li>@Service – business logic layer</li><li>@Repository – persistence layer (adds exception translation)</li></ul><pre>@Service<br>public class UserService {<br>}</pre><p>While technically equivalent to @Component, using semantic stereotypes improves readability.</p><p><strong>@Configuration, </strong><strong>@Bean, </strong><strong>@Profile</strong> Used for explicit bean definitions and environment-specific wiring. Scope annotations @Scope(&quot;prototype&quot;) and @RequestScope.</p><pre>@Configuration<br>public class AppConfig {<br>    @Bean<br>    @Profile(&quot;dev&quot;)<br>    public DataSource devDataSource() {<br>        return DataSourceBuilder.create()<br>          .url(&quot;jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1&quot;)<br>          .driverClassName(&quot;org.h2.Driver&quot;)<br>          .build();<br>    }<br>}</pre><p>Use this when auto-configuration isn’t enough.</p><h4>Dependency Injection &amp; Properties</h4><p>Spring is a dependency injection framework at its core.</p><p><strong>@Autowired &amp; </strong><strong>@Qualifier</strong></p><p>Can be applied to:</p><ul><li>Constructor — for single-constructor classes</li><li>Setter</li><li>Field</li></ul><p>Since Spring 4.3, <strong>if a class has a single constructor, no annotation is required</strong>. Adding final to dependencies is a &quot;must-have&quot; best practice for immutability.</p><pre>@Service<br>public class OrderService {<br>    private final PaymentService service;<br>    public OrderService(PaymentService service) {<br>        this.service = service;<br>    }<br>}</pre><p>Use @Qualifier when multiple beans of the same type exist.</p><p><strong>@Value vs </strong><strong>@ConfigurationProperties</strong></p><p>Inject configuration values:</p><pre>@Value(&quot;${app.timeout}&quot;)<br>private int timeout;</pre><p>For structured configuration:</p><p>In Spring Boot 3+, constructor binding is the default for records.</p><pre>@ConfigurationProperties(prefix = &quot;app&quot;)<br>public record AppProperties(int timeout) {}<br><br>// Option 1: Explicit registration<br>@EnableConfigurationProperties(AppProperties.class)<br><br>// Option 2: Classpath scanning (recommended for larger apps)<br>@SpringBootApplication<br>@ConfigurationPropertiesScan<br>public class Application { }</pre><p>Prefer @ConfigurationProperties for maintainability and type safety. This requires @ConfigurationPropertiesScan or @EnableConfigurationProperties.</p><h4>Web / REST</h4><p>Spring Boot’s web layer is annotation-driven.</p><h4>@RestController</h4><p>Combines:</p><ul><li>@Controller</li><li>@ResponseBody</li></ul><p>Every method returns data directly (JSON by default).</p><pre>@RestController<br>@RequestMapping(&quot;/users&quot;)<br>public class UserController {<br>}</pre><p><strong>@RequestMapping and shortcuts</strong></p><ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li><li>@PatchMapping</li></ul><pre>@GetMapping(&quot;/{id}&quot;)<br>public User getUser(@PathVariable Long id) {<br>    return userService.findById(id);<br>}</pre><p><strong>Request &amp; Response Binding Annotations</strong></p><ul><li>@PathVariable → /users/{id}</li><li>@RequestParam → /users?page=1</li><li>@RequestBody → Deserialize JSON into object</li><li>@ResponseBody → Serialize return value, @RestController already applies it globally.</li></ul><pre>@PostMapping<br>public User create(@RequestBody @Valid CreateUserRequest request) {<br>    return userService.create(request);<br>}</pre><p><strong>@ControllerAdvice&amp; </strong><strong>@RestControllerAdvice &amp; </strong><strong>@ExceptionHandler</strong></p><p>Global error handling:</p><pre>@RestControllerAdvice<br>public class GlobalExceptionHandler {<br><br>    @ExceptionHandler(UserNotFoundException.class)<br>    public ResponseEntity&lt;Void&gt; handle(UserNotFoundException ex) {<br>        return ResponseEntity.notFound().build();<br>    }<br>}</pre><p>Keeps controllers clean and consistent. @RestControllerAdvice automatically applies @ResponseBody.</p><h4>Data / JPA</h4><p>Spring Data simplifies persistence dramatically.</p><p><strong>@Entity, </strong><strong>@Id, </strong><strong>@GeneratedValue</strong> Defines ORM mapping.</p><pre>@Entity<br>public class User {<br>    @Id<br>    @GeneratedValue(strategy = GenerationType.IDENTITY)<br>    private Long id;<br>}</pre><p><strong>@Transactional</strong> Controls transaction boundaries.</p><pre>@Service<br>public class TransferService {<br><br>    @Transactional<br>    public void transferMoney(Long fromId, Long toId, BigDecimal amount) {<br>        // business logic<br>    }<br>}</pre><p>Applies at class or method level. Important in service layer — not controllers. Transactions only work through Spring proxies. <br>If a method is:</p><ul><li>private</li><li>called from the same class</li><li>outside a proxied bean</li></ul><p>It won’t be transactional.</p><h4>Messaging &amp; Event Streaming</h4><p>Modern applications are rarely synchronous.</p><p><strong>@KafkaListener</strong> For consuming Apache Kafka messages:</p><pre>@KafkaListener(<br>    topics = &quot;orders&quot;,<br>    groupId = &quot;order-service&quot;<br>)<br>public void handle(OrderEvent event) {<br>}</pre><p><strong>@JmsListener</strong> For JMS-based brokers:</p><pre>@JmsListener(destination = &quot;queue.orders&quot;)<br>public void receive(String message) {<br>}</pre><p><strong>Spring Application Events</strong> Internal event system.</p><pre>@EventListener<br>public void onOrderCreated(OrderCreatedEvent event) {<br>}</pre><p>For transactional guarantees:</p><pre>@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) // default<br>public void handleAfterCommit(OrderCreatedEvent event) {<br>    // fires only if the surrounding transaction committed successfully<br>}</pre><p>Add @Async (requires @EnableAsync) for asynchronous handling.</p><h4>Validation &amp; Null Safety</h4><p>Validation is declarative in Spring Boot.</p><p><strong>Common Validation Annotations</strong></p><ul><li>@NotNull</li><li>@NotBlank</li><li>@NotEmpty</li><li>@Size</li><li>@Email</li></ul><pre>public class CreateUserRequest {<br>    @NotBlank<br>    private String name;<br>}</pre><p>Triggered via:</p><pre>@PostMapping<br>public User create(@RequestBody @Valid CreateUserRequest request) {<br>    return userService.create(request);<br>}</pre><p><strong>Null Safety Annotations — from JSpecify</strong></p><ul><li>@NonNull</li><li>@Nullable</li><li>@NullMarked</li><li>@NullUnmarked</li></ul><h4>Testing Annotations</h4><p>Testing in Spring Boot is slice-based and powerful.</p><p><strong>@SpringBootTest</strong> Loads full application context.</p><pre>@SpringBootTest<br>class ApplicationTests {<br>}</pre><p><strong>@WebMvcTest</strong> Loads only MVC layer.</p><pre>@WebMvcTest(UserController.class)<br>class UserControllerTest {<br>}</pre><p><strong>@MockitoBean</strong> &amp; <strong>@MockitoSpyBean &amp; </strong><strong>@TestConfiguration</strong></p><ul><li><strong>@</strong>MockitoBean replaces a bean in context</li><li>@TestConfiguration provides test-specific beans</li><li>In Spring Boot 3.4+, @MockBean and @SpyBean are deprecated in favor of @MockitoBean and @MockitoSpyBean. In Boot ≤3.3, use @MockBean.</li></ul><h4>Final Takeaways</h4><p>Spring Boot annotations are not just conveniences. Annotations are not decoration. They are executable architecture. Treat them intentionally.</p><p>When grouped properly, they reveal a clean layering model:</p><ul><li>Core setup defines the application structure.</li><li>Dependency injection wires components.</li><li>Web annotations expose APIs.</li><li>Data annotations manage persistence and transactions.</li><li>Messaging and events support asynchronous systems.</li><li>Validation protects data integrity.</li><li>Testing annotations ensure reliability.</li></ul><p>The more intentionally you use them, the clearer your application becomes.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2aaca52762d9" width="1" height="1" alt="">

---
layout: post
title: "[MM’s] Boot Notes — Simpler, Smarter HTTP Clients in Spring 7"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-simpler-smarter-http-clients-in-spring-7-4029dfca64ce?source=rss-f1368b7746f7------2
tag:
- feign
- http-client
- spring-boot
- programming
- java
---

<h3>[MM’s] Boot Notes — Spring’s HTTP Client Revolution: Goodbye Feign, Hello @HttpExchange</h3><h4>Discover @HttpExchange and HttpService Registry for native, declarative client design.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*j0qL-ZfY-gg5eRpr6HE1SQ.jpeg" /><figcaption>Simpler, Smarter HTTP Clients in Spring</figcaption></figure><p>For years, Spring developers have reached for <strong>RestTemplate</strong> or <strong>OpenFeign</strong> to make HTTP calls between services. Both have served well — but each came with trade-offs.<br><strong>RestTemplate</strong> was synchronous and verbose; Feign was declarative but external.</p><p>With <strong>Spring Framework 7</strong>, the game changes. HTTP client support finally becomes <strong>native</strong>, <strong>declarative</strong> and <strong>type-safe</strong> — no third-party dependencies, no boilerplate factories and full Spring Boot integration.</p><h4>⏩ TL;DR (Quick Recap)</h4><ul><li><strong>Native &amp; Declarative:</strong> @HttpExchange brings Feign-like clients directly into Spring.</li><li><strong>Auto-Configured:</strong> @ImportHttpServices groups and registers them automatically.</li><li><strong>Integrated:</strong> Works seamlessly with Boot, Cloud and Security.</li><li><strong>Future-Ready:</strong> Built on RestClient / WebClient, supports API versioning and Virtual Threads.</li><li><strong>Goodbye Feign:</strong> No external dependency, full Spring support.</li></ul><h4>1. The Problem with Traditional HTTP Clients</h4><p>For more than a decade, RestTemplate was the default way to call remote APIs. But the template-style API began to show its age:</p><ul><li>Only synchronous execution</li><li>Verbose configuration and limited extensibility</li><li>Incompatible with new features like API versioning</li><li><strong>AsyncRestTemplate</strong> already deprecated</li></ul><p><strong>OpenFeign</strong>, popularized through Spring Cloud, fixed some of this by letting developers <strong>declare interfaces</strong> for remote services. But it was never truly Spring-native. It lived in its own dependency world, requiring extra configuration, version alignment and adapter glue.</p><p>Spring developers have long wanted the <strong>declarative simplicity of Feign</strong>, without the external baggage.</p><h4>2. Enter Spring’s Declarative Model</h4><p>At the heart of the new approach lies the @HttpExchange annotation—a way to define HTTP clients as <strong>plain Java interfaces</strong>.</p><p><strong>@HttpExchange </strong>was introduced in Spring 6, enhanced in Spring 7.</p><pre>public interface ProductService {<br>@GetExchange(&quot;/objects&quot;)<br>    List&lt;Product&gt; getAllProducts();<br>    @GetExchange(&quot;/objects/{id}&quot;)<br>    Product getProductById(@PathVariable String id);<br>}</pre><p>Creating a live, type-safe proxy for this interface takes just a few lines:</p><pre>var client = RestClient.create(&quot;https://api.restful-api.dev&quot;);<br>var factory = HttpServiceProxyFactory<br>        .builderFor(RestClientAdapter.create(client))<br>        .build();<br>var service = factory.createClient(ProductService.class);</pre><p>That’s it — no Feign, no custom bean setup. Your interface doubles as <strong>both documentation and client</strong>.</p><p>This design reuses the same underlying HTTP infrastructure as RestClient or WebClient, so you choose whichever client suits your app—imperative or reactive—without rewriting logic.</p><h4>3. Organizing Clients with the Registry</h4><p>Declaring one or two clients is easy; managing dozens quickly becomes repetitive.<br> Spring 7 introduces the <strong>Http Service Registry</strong>, which automates proxy creation and configuration.</p><p>Instead of declaring each client bean manually, you group related interfaces and let Spring register them for you.</p><pre>@Configuration<br>@ImportHttpServices(group = &quot;product&quot;,<br>        types = { ProductService.class })<br>public class HttpServiceConfig { }</pre><p>Each group shares the same configuration (base URL, timeouts, authentication, etc.).<br> Behind the scenes, Spring creates and wires all the necessary proxy beans.</p><p>You can even fine-tune groups programmatically:</p><pre>@Bean<br>RestClientHttpServiceGroupConfigurer groupConfigurer() {<br>    return groups -&gt; groups<br>        .filterByName(&quot;product&quot;)<br>        .forEachClient((_, builder) -&gt;<br>            builder.baseUrl(&quot;https://api.restful-api.dev&quot;));<br>}</pre><p>Or move configuration entirely to properties:</p><pre>spring.http.client.service.group.product.base-url=https://api.restful-api.dev<br>spring.http.client.service.read-timeout=2s<br>spring.http.client.service.connect-timeout=5s</pre><p>No more repetitive factory beans — the registry scales automatically with your service list.</p><h4>4. Built-in Integration: Boot, Cloud, and Security</h4><p>The new registry model is tightly woven into the Spring ecosystem:</p><ul><li><strong>Spring Boot 4.0</strong> automatically configures RestClient or WebClient for each group.</li><li><strong>Spring Cloud 2025.1</strong> adds load-balancing and circuit-breaking at the group level.</li><li><strong>Spring Security 7.0</strong> detects @ClientRegistrationId annotations for OAuth2 token propagation.</li></ul><p>In other words, you get <strong>end-to-end service-to-service communication</strong> with almost no glue code.</p><h4>5. Customization and Error Handling</h4><p>Error handling can now be defined once — at the adapter level — and shared across all clients.</p><pre>var restClient = RestClient.builder()<br>    .defaultStatusHandler(HttpStatusCode::isError,<br>        (request, response) -&gt; {<br>            throw new CustomApiException(response.getStatusCode());<br>        })<br>    .build();<br>var factory = HttpServiceProxyFactory<br>    .builderFor(RestClientAdapter.create(restClient))<br>    .build();</pre><p>You can also extend parameter resolution with custom logic:</p><pre>static class SearchQueryResolver implements HttpServiceArgumentResolver {<br>@Override<br>    public boolean resolve(Object arg, MethodParameter param,<br>                           HttpRequestValues.Builder values) {<br>        if (param.getParameterType().equals(Search.class)) {<br>            var search = (Search) arg;<br>            values.addRequestParameter(&quot;owner&quot;, search.owner());<br>            values.addRequestParameter(&quot;query&quot;, search.query());<br>            return true;<br>        }<br>        return false;<br>    }<br>}</pre><h4>6. Choosing the Right HTTP Client</h4><p>Spring 7 clarifies which client to use for which scenario:</p><ul><li>Client Traditional MVC apps needing synchronous calls -&gt; <strong>RestClient</strong></li><li>Reactive, non-blocking, streaming workloads -&gt; <strong>WebClient</strong></li><li>Multiple organized APIs with declarative configuration -&gt; <strong>@HttpExchange</strong> interfaces + Registry</li></ul><p><strong>Pro tip:</strong> RestClient pairs beautifully with Java 21’s <strong>Virtual Threads</strong> and <strong>Structured Concurrency</strong>, giving you high concurrency without reactive complexity.</p><h4>7. From Feign to Spring-Native</h4><p>If you’ve used Feign before, the transition feels familiar:</p><ul><li>@FeignClient(&quot;users&quot;) → @HttpExchange +@ImportHttpServices(group=&quot;users&quot;)</li><li>Custom configuration per client → Group-level configuration via properties or Configurer</li><li>Separate dependency (spring-cloud-openfeign) → Built into Spring Framework core</li><li>Manual setup for OAuth2 or load-balancing → Automatic via Boot, Cloud, and Security</li></ul><p>In short, Spring 7 <strong>turns Feign’s best ideas into native Spring features</strong> — with less friction, less configuration, and better long-term support.</p><h4>8. Migrating from RestTemplate or Feign</h4><p>Migration is straightforward:</p><p><strong>→ From RestTemplate:</strong><br> Switch to RestClient for a fluent, modern API.<br> You can wrap existing RestTemplate instances temporarily while you migrate.</p><p><strong>→ From Feign:</strong><br> Replace Feign interfaces with @HttpExchange equivalents.<br> Method signatures and annotations remain nearly identical.</p><p>Most Feign clients can be ported in minutes. Once migrated, you get first-class support for Boot configuration, Cloud integration and future enhancements like API versioning.</p><h4>9. Beyond the Basics: New Testing and Extensibility</h4><p>Spring 7 also introduces the <strong>RestTestClient</strong>, a companion for integration testing.<br> It allows you to test controllers and routes — either against a live server or mock endpoints — using the same fluent API as RestClient.</p><p>This unifies the testing experience across reactive and traditional stacks and is a likely successor to TestRestTemplate.</p><h4>10. The Future of HTTP Clients in Spring</h4><p>Spring 7 marks a major milestone:</p><ul><li><strong>RestTemplate</strong> begins its deprecation path (announcement in 7.0, deprecated in 7.1, removed in 8.0).</li><li><strong>RestClient</strong> becomes the default for synchronous code.</li><li><strong>WebClient</strong> remains the reactive option.</li><li><strong>@HttpExchange</strong> and the <strong>Http Service Registry</strong> unify both worlds under a single, declarative model.</li></ul><p>By Spring 8, all HTTP client usage will revolve around these unified, modern APIs. It’s cleaner, faster, and — finally — Spring-native.</p><h3>Why It Matters</h3><p>This evolution isn’t just about new APIs. It’s about <strong>consistency and simplicity</strong>.</p><p>You define interfaces.<br> Spring builds proxies.<br> Boot, Cloud, and Security wire everything else.</p><p>HTTP clients in Spring now feel like they always belonged there.<br> And for every developer who’s ever thought, <em>“I wish Feign were just part of Spring,”</em> — that wish just came true.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4029dfca64ce" width="1" height="1" alt="">

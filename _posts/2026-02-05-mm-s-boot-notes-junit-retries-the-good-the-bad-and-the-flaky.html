---
layout: post
title: "[MM’s] Boot Notes — JUnit Retries: The Good, The Bad and The Flaky"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-junit-retries-the-good-the-bad-and-the-flaky-a2268c57a188?source=rss-f1368b7746f7------2
tag:
- spring-boot
- programming
- junit
- java
---

<h3>[MM’s] Boot Notes — JUnit Retries: The Good, The Bad and The Flaky</h3><h4>Recognizing and managing non-deterministic test failures.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*UaiYOrmiy4gL4rQguGlV2g.png" /><figcaption>JUnit Retries: The Good, The Bad and The Flaky</figcaption></figure><p>Every developer knows the steps.</p><p>A pull request fails CI.<br>You open the logs.<br>Nothing obvious.<br>You click <strong>“Re-run failed jobs”</strong>.<br>Everything passes.</p><p>Welcome to flaky tests — failures that appear and disappear without code changes. They’re not just annoying; they’re expensive. In a suite of 1,000 tests, even a <strong>1% flakiness rate</strong> almost guarantees daily CI failures.</p><p>The uncomfortable truth? Some flaky tests are here to stay for a while. The challenge isn’t just fixing them — it’s maintaining a stable pipeline without pretending they don’t exist.</p><p>⚡ <strong>TL;DR (Quick Recap)</strong></p><ul><li>Flaky tests don’t fail once — they fail your process.</li><li>JUnit 5 extensions allow <strong>retries</strong> without restarting the JVM or hiding failures.</li><li>Retries should be <strong>limited, logged and visible</strong> — a safety net, not a solution.</li><li>Use retry logic to stabilize CI while actively fixing the root causes.</li></ul><h4>Why Tests Become Flaky</h4><p>Most non-deterministic failures fall into familiar categories:</p><ul><li><strong>Asynchronous timing </strong>Reactive pipelines, message brokers or background jobs tested with sleep() instead of explicit waits.</li><li><strong>Infrastructure noise </strong>Network hiccups, shared CI runners or transient cloud service issues.</li><li><strong>State leakage </strong>Dirty databases, static fields or parallel tests stepping on each other.</li></ul><p>Retries don’t fix any of these — but they can keep your pipeline usable while you work on them.</p><h4>Retry Strategies (and Their Limits)</h4><p>Before adding retry logic, it’s worth knowing your options:</p><ul><li><strong>Fix the root cause </strong>Always the goal. Often not immediate.</li><li><strong>Quarantine flaky tests </strong>Move them into a non-blocking suite.</li><li><strong>Build-tool retries </strong>Maven Surefire or Gradle retries work — but they restart the JVM.</li><li><strong>External libraries</strong>: JUnit Pioneer’s @RetryingTest</li><li><strong>JUnit extensions </strong>Fine-grained, explicit and local to the test lifecycle.</li></ul><h4>A retries with JUnit</h4><p>JUnit exposes the <strong>InvocationInterceptor</strong> interface, which allows interception of test failures <em>inside</em> the engine.</p><ul><li>No JVM restarts</li><li>No build-tool magic</li><li>Full access to test context and state</li></ul><p>Let’s build a retry extension that is small, visible and transparent.</p><h4>The Retry Extension</h4><pre>@Target(ElementType.METHOD)<br>@Retention(RetentionPolicy.RUNTIME)<br>@ExtendWith(RetryableExtension.class)<br>public @interface Retryable {<br>    int maxAttempts() default 3;<br>}</pre><pre>public class RetryableExtension implements InvocationInterceptor {<br>    private static final Logger log = LoggerFactory.getLogger(RetryableExtension.class);<br>    private static final String RETRY_COUNT_KEY = &quot;retry_count&quot;;<br><br>    @Override<br>    public void interceptTestMethod(@NonNull Invocation&lt;Void&gt; invocation,<br>                                    @NonNull ReflectiveInvocationContext&lt;Method&gt; invocationContext,<br>                                    ExtensionContext extensionContext) throws Throwable {<br><br>        var retryable = extensionContext.getRequiredTestMethod()<br>                .getAnnotation(Retryable.class);<br><br>        if (retryable == null) {<br>            invocation.proceed();<br>            return;<br>        }<br><br>        var maxAttempts = retryable.maxAttempts();<br>        var store = getStore(extensionContext);<br><br>        for (var attempt = 0; attempt &lt; maxAttempts; attempt++) {<br>            store.put(RETRY_COUNT_KEY, attempt);<br><br>            try {<br>                if (attempt == 0) {<br>                    // First attempt - use normal JUnit invocation (includes full lifecycle)<br>                    invocation.proceed();<br>                } else {<br>                    // Retry - re-invoke test method only<br>                    // Note: @BeforeEach/@AfterEach won&#39;t run again<br>                    extensionContext.getRequiredTestMethod()<br>                            .invoke(extensionContext.getRequiredTestInstance());<br>                }<br><br>                // Test passed<br>                if (attempt &gt; 0) {<br>                    log.info(&quot;✓ Test &#39;{}&#39; passed on attempt {}/{}&quot;,<br>                            extensionContext.getDisplayName(),<br>                            attempt,<br>                            maxAttempts<br>                    );<br>                }<br>                return; // Exit on success<br><br>            } catch (Throwable throwable) {<br>                // Unwrap reflection exceptions to get the real cause<br>                var actualException = unwrapException(throwable);<br><br>                if (attempt &lt; (maxAttempts - 1)) {<br>                    log.warn(&quot;✗ Test &#39;{}&#39; failed on attempt {}/{}. Error: {} - retrying...&quot;,<br>                            extensionContext.getDisplayName(),<br>                            attempt,<br>                            maxAttempts,<br>                            actualException.getMessage()<br>                    );<br>                } else {<br>                    log.error(&quot;✗ Test &#39;{}&#39; failed after {} attempts. Giving up.&quot;,<br>                            extensionContext.getDisplayName(),<br>                            maxAttempts<br>                    );<br>                    throw actualException;<br>                }<br>            }<br>        }<br>    }<br><br>    /**<br>     * Unwrap InvocationTargetException to get the actual test failure.<br>     */<br>    private Throwable unwrapException(Throwable throwable) {<br>        if (throwable instanceof java.lang.reflect.InvocationTargetException) {<br>            var cause = throwable.getCause();<br>            return cause != null ? cause : throwable;<br>        }<br>        return throwable;<br>    }<br><br>    private ExtensionContext.Store getStore(ExtensionContext context) {<br>        return context.getStore(<br>                ExtensionContext.Namespace.create(getClass(), context.getRequiredTestMethod())<br>        );<br>    }<br>}</pre><h4>How This Works</h4><ul><li><strong>Namespaced state </strong>Each test method gets its own retry counter — no leakage between tests.</li><li><strong>Same test instance </strong>The retry runs on the existing test object, preserving context.</li><li><strong>Hard stop </strong>Once retries are exhausted, the original failure is rethrown.</li></ul><p><strong>Limitations</strong></p><ul><li><strong>Bypasses Other Extensions</strong>: Won’t work with other lifecycle extensions</li><li><strong>No Parallel Support</strong>: May fail with @Execution(CONCURRENT)</li><li><strong>Nested Tests</strong>: Doesn&#39;t handle @Nested test classes</li><li><strong>More Complex</strong>: More code paths, more potential bugs</li></ul><p>For production code requiring full lifecycle re-execution, consider:</p><p><strong>JUnit Pioneer’s @RetryingTest</strong></p><ul><li>Battle-tested in production</li><li>Handles all edge cases correctly</li><li>Supports parallel execution</li><li>Works with nested tests</li></ul><h4>Using the Extension</h4><p>Apply it where flakiness is expected — typically integration tests.</p><pre><br>class CloudServiceIntegrationTest {<br>    @Test<br>    @Retryable<br>    void unstableExternalDependency() {<br>        assertTrue(remoteService.call().isSuccessful());<br>    }<br>}</pre><p>Unit tests should remain deterministic.</p><h4>Engineering Trade-offs</h4><p>Retries are a <strong>loan against technical debt</strong>. Treat them accordingly.</p><ul><li><strong>Longer CI times </strong>Acceptable if scoped to a small test set.</li><li><strong>Stateful side effects </strong>Tests must clean up after themselves.</li><li><strong>False confidence </strong>A “flaky pass” is still a failure signal.</li></ul><p>A simple rule that works well in practice:</p><blockquote><em>If more than </em><strong><em>5% of builds rely on retries</em></strong><em>, stop feature work and fix the system.</em></blockquote><p>Retries should <em>buy time</em>, not erase accountability.</p><h4>Final Takeaways</h4><p>JUnit extension model gives us a precise tool for handling flaky tests without polluting build logic or restarting the JVM. Used carefully, a retry extension can stabilize CI pipelines while teams focus on fixing real problems.</p><p>Use retries to keep your pipeline green. Use logs and metrics to keep your architecture honest.</p><p>You can find example of code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a2268c57a188" width="1" height="1" alt="">

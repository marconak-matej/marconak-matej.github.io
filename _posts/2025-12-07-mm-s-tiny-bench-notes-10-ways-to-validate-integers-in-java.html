---
layout: post
title: "[MM’s] Tiny Bench Notes — 10 Ways to Validate Integers in Java"
canonical_url: https://marconak-matej.medium.com/mms-tiny-bench-notes-10-ways-to-validate-integers-in-java-6a4788a18872?source=rss-f1368b7746f7------2
tag:
- java
- jmh
- programming
- integer
---

<h3>[MM’s] Tiny Bench Notes — 10 Ways to Validate Integers in Java</h3><h4>A dive into the performance costs of simple code in high-throughput environments.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MvdK4JYinMhtPqNoDguZlQ.png" /><figcaption>10 Ways to Validate Integers in Java</figcaption></figure><p>If you’ve ever written a quick validation routine if integer, you probably reached for Integer.parseInt() inside a try-catch. It works, it’s simple and the error messages are clear. But when your service processes tens of thousands of strings per second, that innocent line becomes a battlefield of allocations, exceptions and surprising bottlenecks.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li>Manual char-by-char validation: <strong>fastest (~6–13 ns/op)</strong></li><li>parseInt with exceptions: <strong>fast for valid inputs, terrible for invalid ones (~537–822 ns/op)</strong></li><li>Regex: <strong>clean, but 3–5× slower than manual approaches</strong></li><li>String.matches(): <strong>slow due to regex compilation every call</strong></li><li>Scanner: <strong>the absolute worst (~4,900 ns/op)</strong></li></ul><h4>Why This Matters Now</h4><p>With modern architectures shifting toward event-driven ingestion, log-heavy analytics and streaming pipelines, applications often validate huge amounts of untrusted text data.</p><p>Micro-optimizations don’t matter in most code, but <strong>validating millions of strings in tight loops absolutely deserves measurement</strong>. And integer parsing is a perfect example of how different Java abstractions behave under stress.</p><h4>The Benchmark Setup</h4><p><strong>The candidates: 10 ways to check if a string is an integer</strong></p><ul><li>Try/Catch</li><li>Try/Catch + pre-check</li><li>Regex (compiled)</li><li>String.matches()</li><li>Manual parsing</li><li>Manual parsing (optimized charAt)</li><li>Manual parsing via char[]</li><li>Java Streams</li><li>Scanner</li><li>Apache Commons–style digit checks</li></ul><p><strong>All approaches followed the same rules:</strong></p><ul><li>Accept optional leading sign (+/-)</li><li>Allow leading zeros</li><li>Reject decimals, whitespace and empty strings</li><li>Ensure the number fits exactly in int range</li></ul><p><strong>Test data included:</strong></p><ul><li>Valid small integers</li><li>Valid large integers</li><li>Values near Integer.MIN and Integer.MAX</li><li>Eight classes of invalid input (whitespace, decimals, hex, overflowing values, etc.)</li></ul><p>Everything was measured using <strong>JMH 1.37 on Java 25</strong>.</p><p>The benchmarks were run on <strong>OpenJDK 25</strong> (Temurin-25+36) with -Xms1g -Xmx1g -XX:+UseG1GC. It measures the <strong>average execution time per operation in nanoseconds</strong>, running in a <strong>shared benchmark state</strong>, with <strong>2 forks (each doing 1 warmup fork)</strong>, <strong>warming up for 5 iterations of 1 second</strong> each, and then measuring <strong>over 10 iterations of 1 second each</strong>.</p><h4>The Winners — Manual Parsing</h4><p>The fastest methods by far were the <strong>manual character-inspection</strong> variants. They consistently delivered:</p><ul><li>Valid inputs: <strong>~9–10 ns/op</strong></li><li>Invalid inputs: <strong>~6–7 ns/op</strong></li><li>Large inputs: <strong>~13 ns/op</strong></li></ul><p><strong>Here’s the winning pseudo approach:</strong></p><pre>function isInteger(text):<br>    if text is null or empty: return false<br>    <br>    index = 0<br>    isNegative = (text[0] == &#39;-&#39;)<br>    <br>    if text[0] is &#39;+&#39; or &#39;-&#39;:<br>        index = 1<br>        if no more characters: return false<br>    <br>    value = 0<br>    for each char from index to end:<br>        if char not in &#39;0&#39;-&#39;9&#39;: return false<br>        value = value * 10 + char<br>        if value exceeds integer bounds: return false<br>    <br>    return true</pre><p><strong>Why it wins</strong></p><ul><li>No allocations</li><li>No exceptions</li><li>No regex state machines</li><li>Fail-fast behavior for invalid characters</li><li>Range checking built directly into the loop</li></ul><p>It’s “old school,” but sometimes the classics are classics for a reason.</p><h4>Try-Catch: Surprisingly Good… Until It Isn’t</h4><p>The typical approach:</p><pre>public boolean isInteger(String text) {<br>    if (text == null || text.isEmpty()) return false;<br>    try {<br>        Integer.parseInt(text);<br>        return true;<br>    } catch (NumberFormatException e) {<br>        return false;<br>    }<br>}</pre><p><strong>Performance</strong></p><ul><li>Valid input: <strong>~9–13 ns/op</strong></li><li>Invalid input: <strong>~537–822 ns/op</strong> ❌</li></ul><p><strong>Why the huge gap?</strong></p><p>Because exceptions in Java aren’t just thrown — they’re <strong>constructed</strong>, <strong>filled with stack traces</strong> and <strong>allocated</strong>, making them <strong>about 80× slower</strong> than a char check.</p><p>Try-catch validation is still great when:</p><ul><li>You expect almost all inputs to be valid</li><li>Exceptions are truly exceptional</li></ul><h4>Regex and Streams</h4><p><strong>Compiled regex</strong></p><ul><li><strong>26–139 ns/op</strong></li><li>Clean and elegant</li><li>But: allocates a new <strong>Matcher</strong> every call</li></ul><p><strong>String.matches()</strong></p><ul><li><strong>92–203 ns/op</strong></li><li>Compiles the regex <em>every single time</em></li><li>Should never be used in hot paths</li></ul><p>Regex is attractive, but performance isn’t its strong suit — especially when range checking still requires a call to parseInt().</p><h4>The Slowest: Scanner</h4><p>Scanner.hasNextInt() might look convenient:</p><pre>  try (var scanner = new java.util.Scanner(text)) {<br>      if (scanner.hasNextInt()) {<br>          scanner.nextInt();<br>          return !scanner.hasNext();<br>      }<br>      return false;<br>  }</pre><p><strong>Performance</strong></p><ul><li><strong>~4,900 ns/op</strong></li><li>~500× slower than manual parsing</li></ul><p>Scanner is built for <em>tokenization</em>, not simple validation. Lots of internal buffering, charset handling and object creation make it a terrible choice here.</p><h4>Approaches Not Covered Above: Quick Notes</h4><p><strong>Java Streams</strong></p><ul><li><strong>19–122 ns/op</strong></li><li>Readable, but adds iteration and lambda overhead</li></ul><p><strong>Apache Commons–Style Digit Checking</strong></p><p>This approach uses Character.isDigit() inside a loop.</p><ul><li><strong>Valid integers:</strong> ~12 ns/op</li><li><strong>Invalid:</strong> ~110 ns/op</li><li>It’s predictable and safer than regex, but noticeably slower than charAt-based manual loops.</li></ul><p><strong>char[] Conversion Approach</strong></p><ul><li><strong>Valid:</strong> ~18 ns/op</li><li><strong>Invalid:</strong> ~17 ns/op</li><li>The extra toCharArray() allocation dominates the cost.</li></ul><h4>Practical Guidance: Choose the Right Tool</h4><p>Here’s when to use each approach:</p><p><strong>Use manual parsing when:</strong></p><ul><li>You care about raw performance</li><li>Your input may contain many invalid values</li><li>You run validation inside a tight loop</li></ul><p><strong>Use try-catch when:</strong></p><ul><li>Data is mostly valid</li><li>Simplicity matters more than speed</li><li>You aren’t in a high-throughput scenario</li></ul><p><strong>Use regex when:</strong></p><ul><li>You need very concise code</li><li>Performance is secondary</li><li>You don’t mind the matcher overhead</li></ul><h4>Final Takeaways</h4><p>Integer validation is a deceptively complex micro-benchmark. What looks clean or idiomatic in everyday Java can behave very differently once scaled into thousands or millions of operations per second.</p><p><strong>From this benchmark:</strong></p><ul><li>Manual character checking is the fastest and most predictable approach.</li><li>Try-catch is excellent for clean data but disastrous for bad input.</li><li>Regex is fine for readability, not for speed.</li><li>Scanner should be avoided entirely for validation.</li></ul><p>You can find all the code on <a href="https://github.com/marconak-matej/tiny-functions-bench">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6a4788a18872" width="1" height="1" alt="">

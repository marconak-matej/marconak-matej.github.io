---
layout: post
title: "[MM’s] Boot Notes — jOOQ"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-jooq-ffe40e522792?source=rss-f1368b7746f7------2
tag:
- flyway
- spring-boot
- jooq
- java
- programming
---

<h3>[MM’s] Boot Notes — jOOQ</h3><h4>Type-Safe SQL with jOOQ in Spring Boot: Beyond the ORM</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*uYGGSp_aNn-RqwPg9HO6Cw.png" /><figcaption>Type-Safe SQL with jOOQ in Spring Boot: Beyond the ORM</figcaption></figure><p>If you’ve ever shipped a production bug caused by a misspelled column name or spent an afternoon debugging an ORM-generated query you didn’t write, you’re not alone. Most teams rely on JPA by default, but as soon as queries get complex, the abstraction starts leaking. SQL ends up split across strings, annotations or XML — with no compile-time guarantees.</p><p><strong>But what if SQL could be type-safe?</strong><br><strong> What if your IDE <em>knew</em> your schema?</strong><br><strong> What if changing a column name updated all queries automatically?</strong></p><p>That’s exactly what <strong>jOOQ</strong> delivers: <em>type-safe SQL in Java</em>, backed by generated code that reflects your real database schema.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li>jOOQ turns your database schema into Java classes, giving you <strong>compile-time SQL validation</strong>.</li><li>Spring Boot integrates jOOQ out of the box through auto-configuration and a managed DSLContext.</li><li>Testcontainers can drive <strong>automated code generation</strong> and <strong>real-database testing</strong> without manual setup.</li><li>Use jOOQ when SQL complexity is high; stick to JPA when CRUD dominates</li></ul><h4>Why Database Access Is Still Hard in 2025</h4><p>Most Spring developers reach for JPA and Hibernate by habit. It’s productive for simple CRUD and convenient for entity relationships. But it struggles when:</p><ul><li>you need multi-join analytical queries</li><li>you require hand-tuned SQL for performance</li><li>you want dynamic queries that aren’t a mess of string concatenation</li><li>you debug N+1 issues that appear “out of nowhere”</li><li>you need <strong>database-specific features</strong> (window functions, CTEs, full-text search)</li></ul><p>Meanwhile, you can write clean, performant SQL you can’t easily reproduce using JPA’s abstractions.</p><p><strong>jOOQ flips the model:</strong><br>Instead of hiding SQL, it <em>embraces it</em>. Your schema becomes your API and jOOQ generates type-safe Java code that mirrors the real database — tables, fields, constraints, indexes, enums, everything.</p><p><strong>The result</strong>: real SQL, checked at compile time, with full IDE auto-completion.</p><h4>Setting Up jOOQ with Spring Boot</h4><p>Let’s walk through setting up a product catalog service using PostgreSQL, jOOQ, Flyway and Testcontainers.</p><p><strong>Dependencies</strong></p><p>Add jOOQ, Flyway and the PostgreSQL driver:</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jooq&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-flyway&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;<br>    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;<br>    &lt;scope&gt;runtime&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><p>Spring Boot auto-configures a DSLContext for you, similar to how Spring Data provides a JpaRepository.</p><h4>Database Schema &amp; Flyway Migration</h4><p>Your initial migration goes into:</p><p>src/main/resources/db/migration/V1__create_products_table.sql</p><pre>CREATE TABLE dbo.products (<br>    id             BIGINT PRIMARY KEY,<br>    name           VARCHAR(200) NOT NULL,<br>    price          DECIMAL(10, 2) NOT NULL,<br>    stock_quantity INTEGER NOT NULL DEFAULT 0,<br>    status         VARCHAR(20) NOT NULL DEFAULT &#39;ACTIVE&#39;<br>);<br>CREATE INDEX idx_products_status ON dbo.products(status);</pre><p>Keeping everything in a dedicated dbo schema avoids mixing business tables with Flyway metadata.</p><h4>Code Generation with Testcontainers</h4><p>This is where jOOQ shines. Instead of generating code from a static local database, you can use Testcontainers to create a <strong>clean, predictable, disposable</strong> PostgreSQL instance during every build.</p><pre>&lt;plugin&gt;<br>    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;<br>    &lt;artifactId&gt;testcontainers-jooq-codegen-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.4&lt;/version&gt;<br>    &lt;executions&gt;<br>        &lt;execution&gt;<br>            &lt;phase&gt;generate-sources&lt;/phase&gt;<br>            &lt;configuration&gt;<br>                &lt;database&gt;<br>                    &lt;type&gt;POSTGRES&lt;/type&gt;<br>                    &lt;containerImage&gt;postgres:16-alpine&lt;/containerImage&gt;<br>                &lt;/database&gt;<br>                &lt;jooq&gt;<br>                    &lt;generator&gt;<br>                        &lt;database&gt;<br>                            &lt;inputSchema&gt;dbo&lt;/inputSchema&gt;<br>                        &lt;/database&gt;<br>                        &lt;target&gt;<br>                            &lt;packageName&gt;io.github.mm.jooq.generated&lt;/packageName&gt;<br>                        &lt;/target&gt;<br>                    &lt;/generator&gt;<br>                &lt;/jooq&gt;<br>            &lt;/configuration&gt;<br>        &lt;/execution&gt;<br>    &lt;/executions&gt;<br>&lt;/plugin&gt;</pre><p>Running:</p><pre>./mvnw generate-sources</pre><p>performs:</p><ol><li>Spin up PostgreSQL via Testcontainers</li><li>Apply Flyway migrations</li><li>Let jOOQ introspect the live schema</li><li>Generate type-safe Java classes</li></ol><p>This ensures your generated code <em>always</em> matches your real database.</p><h4>Spring Boot Configuration</h4><pre>spring:<br>  datasource:<br>    url: jdbc:postgresql://localhost:5432/jooqdb<br>    username: user<br>    password: pass123<br>  jooq:<br>    sql-dialect: POSTGRES</pre><h4>Writing Type-Safe SQL with jOOQ</h4><p>Here’s a simple repository using the generated PRODUCTS table class.</p><h3>Basic CRUD</h3><pre>@Repository<br>public class ProductRepository {<br>    private final DSLContext dsl;<br>    public ProductsRecord create(CreateProductRequest request) {<br>        return dsl.insertInto(PRODUCTS)<br>                .set(PRODUCTS.NAME, request.name())<br>                .set(PRODUCTS.PRICE, request.price())<br>                .set(PRODUCTS.STATUS, request.status().name())<br>                .returningResult(PRODUCTS.asterisk())<br>                .fetchOne();<br>    }<br>    public Optional&lt;ProductsRecord&gt; findById(Long id) {<br>        return Optional.ofNullable(<br>            dsl.selectFrom(PRODUCTS)<br>               .where(PRODUCTS.ID.eq(id))<br>               .fetchOne()<br>        );<br>    }<br>}</pre><p>Try passing a String into .PRICE (a BigDecimal column)—it won’t compile.<br> Try referencing a non-existent column—your IDE flags it instantly.</p><h4>Dynamic Queries Without Pain</h4><p>Building flexible query filters is trivial with jOOQ’s composable Condition DSL:</p><pre>public List&lt;ProductsRecord&gt; findAll(ProductStatus status, String category) {<br>    Condition condition = DSL.trueCondition();<br>    if (status != null) {<br>        condition = condition.and(PRODUCTS.STATUS.eq(status.name()));<br>    }<br>    if (category != null) {<br>        condition = condition.and(PRODUCTS.CATEGORY.equalIgnoreCase(category));<br>    }<br>    return dsl.selectFrom(PRODUCTS)<br>              .where(condition)<br>              .fetch();<br>}</pre><p>No concatenated SQL fragments. No runtime surprises. Just type-safe, readable query assembly.</p><h4>Testing Against Real Databases with Testcontainers</h4><p>Your Spring Boot tests can run against a real PostgreSQL instance:</p><pre>@TestConfiguration<br>public class TestcontainersConfiguration {<br>    @Bean<br>    @ServiceConnection<br>    public PostgreSQLContainer&lt;?&gt; postgresContainer() {<br>        return new PostgreSQLContainer&lt;&gt;(&quot;postgres:16-alpine&quot;);<br>    }<br>}</pre><p>This eliminates:</p><ul><li>H2 incompatibilities</li><li>SQL differences between dev/test/prod</li><li>Mocking that hides real issues</li></ul><p>If your SQL works here, it will work in production.</p><h4>How jOOQ Compares: Making the Right Choice</h4><h4>When to Choose jOOQ</h4><p><strong>Use jOOQ when:</strong></p><ul><li>Complex analytical queries are common (reporting, dashboards, analytics)</li><li>You need full SQL expressiveness (CTEs, window functions, lateral joins)</li><li>Compile-time safety is critical for your team</li><li>Your team is comfortable writing SQL</li><li>Database-first design fits your workflow</li><li>You’re building microservices with complex data aggregation</li></ul><p><strong>Real-world examples:</strong></p><ul><li>Financial reporting systems</li><li>E-commerce analytics platforms</li><li>Real-time dashboards with complex aggregations</li><li>Systems requiring database-specific optimizations</li></ul><h4>When to Choose Spring Data JPA</h4><p><strong>Use JPA when:</strong></p><ul><li>Most queries follow simple CRUD patterns</li><li>Entity relationships and OOP mapping are central</li><li>Your team prefers object-oriented persistence</li><li>Cross-database portability is required</li><li>Domain-first design is your approach</li></ul><p><strong>Real-world examples:</strong></p><ul><li>Admin panels and backoffice tools</li><li>Content management systems</li><li>Standard business applications</li><li>Systems with rich domain models</li></ul><h4><strong>Other Options Worth Mentioning</strong></h4><p><strong>MyBatis</strong>: Use when you want full SQL control, but don’t need type safety. Good for teams transitioning from legacy systems.<br><strong>Spring JdbcClient or JDBCTemplate</strong>: Use for simple applications where raw SQL with minimal abstraction is sufficient. Avoid when dynamic queries become complex. <br><strong>EclipseLink: </strong>You want an alternative JPA implementation<br><strong>Kotlin Options (Exposed &amp; Ktorm)</strong>: If you’re in the Kotlin ecosystem, Exposed offers a type-safe SQL DSL, and Ktorm provides a lightweight functional ORM. Both are excellent, but lack Java interoperability.<br><strong>QueryDSL</strong>: You need to stay within the JPA ecosystem and want better query readability than Criteria API</p><h4>Final Takeaways</h4><p><strong>jOOQ</strong> gives you the best of both worlds: SQL’s expressiveness with Java’s type safety. When combined with Spring Boot, Testcontainers and Flyway, you get a clean, maintainable, fully validated persistence layer.</p><p>Use <strong>jOOQ</strong> when:</p><ul><li>SQL is central to your system</li><li>complex analytical queries are frequent</li><li>compile-time validation is valuable</li></ul><p>Stick to Spring Data JPA when CRUD dominates or choose QueryDSL when you want type-safety without leaving JPA. Kotlin developers can explore Exposed or Ktorm.</p><p>For many teams, <strong>jOOQ</strong> becomes the missing middle ground between raw SQL and ORMs. Once you experience real compile-time SQL safety, it’s hard to go back.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ffe40e522792" width="1" height="1" alt="">

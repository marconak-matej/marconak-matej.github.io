---
layout: post
title: "[MM’s] Boot Notes — OpenRewrite"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-openrewrite-00ca79f5ecb9?source=rss-f1368b7746f7------2
tag:
- openrewrite
- programming
- spring-boot
- java
---

<h3>[MM’s] Boot Notes — OpenRewrite</h3><h4>Automated, auditable migrations to Java 25 and Spring Boot 4</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4n8_y60g1PQO94sVpf7HEQ.png" /><figcaption>Automated, auditable migrations to Java 25 and Spring Boot 4</figcaption></figure><p>Upgrading a large Java codebase is rarely blocked by one catastrophic breaking change. It’s blocked by <strong>hundreds of small, mechanical, easy-to-miss updates</strong> scattered across build files, deprecated APIs, configuration properties, and test infrastructure.</p><p>That’s exactly the kind of work humans are bad at — and exactly the problem <strong>OpenRewrite</strong> is designed to solve.</p><h4>⚡ <strong>TL;DR (Quick Recap)</strong></h4><ul><li><strong>OpenRewrite</strong> automates large-scale <strong>Java</strong> and <strong>Spring Boot</strong> migrations safely and consistently.</li><li><strong>Java 25</strong> and <strong>Spring Boot 4</strong> upgrades are mostly <em>mechanical</em>, not conceptual — perfect for automation.</li><li><strong>OpenRewrite</strong> applies semantic, AST-aware transformations, not brittle text rewrites — <strong>LST (Lossless Semantic Tree)</strong></li><li>Use it to eliminate migration toil, not to skip testing or validation.</li></ul><h4>What Is OpenRewrite?</h4><p>OpenRewrite is an open-source automated refactoring ecosystem built around <strong>semantic code transformations</strong>. Unlike traditional search-and-replace tools, OpenRewrite operates on the <strong>Abstract Syntax Tree (AST)</strong> of your code. That means it understands:</p><ul><li>Language constructs</li><li>Type hierarchies</li><li>Build metadata</li><li>Configuration semantics</li></ul><p>At its core, OpenRewrite runs <strong>recipes</strong> — curated sets of refactorings maintained by framework and platform experts — that encode <em>how migrations should actually be done</em>.</p><h4>Why OpenRewrite Exists (and Why It Matters Now)</h4><p>Most teams don’t avoid platform upgrades because they’re hard to understand. They avoid them because they’re <strong>time-consuming, error-prone and boring</strong>.</p><p>Every major Java or Spring Boot upgrade introduces:</p><ul><li>Deprecated APIs with non-obvious replacements</li><li>Build and plugin alignment issues</li><li>Configuration properties that silently stop working</li><li>Framework defaults that become explicit</li></ul><p>Do this manually across dozens of modules or microservices and you’ll:</p><ul><li>Miss edge cases</li><li>Introduce inconsistencies</li><li>Burn engineering time on low-value work</li></ul><p><strong>OpenRewrite</strong> changes the equation by turning migrations into <strong>repeatable, reviewable and automated refactors</strong>.</p><p><strong>The OpenRewrite Philosophy</strong></p><p>OpenRewrite recipes are not blind rewrites. They encode <strong>maintainer-level intent</strong>:</p><ul><li>What changed</li><li>What was removed</li><li>What must now be explicit</li><li>What is safe to automate</li></ul><p>Three practical benefits:</p><ol><li><strong>Consistency </strong>Every deprecated pattern is migrated the same way, everywhere.</li><li><strong>Auditability </strong>Dry runs produce full diffs and reports before anything changes.</li><li><strong>Safety </strong>Transformations apply only when the intent is unambiguous.</li></ol><p>OpenRewrite won’t guarantee identical runtime behavior — that’s your tests’ job — but it <em>will</em> guarantee that the mechanical work is done correctly and consistently.</p><h4>Migrating to Java 25 with OpenRewrite</h4><p>Java upgrades rarely fail because teams misunderstand new language features. They fail because <strong>small changes accumulate across large codebases</strong>.</p><p><strong>The Java 25 Migration Entry Point</strong></p><pre>org.openrewrite.java.migrate.UpgradeToJava25</pre><p>This composite recipe handles migrations from Java 8, 11, 17 and 21, applying only the transformations relevant to your current baseline.</p><h4>What the Java 25 Recipe Actually Does</h4><p><strong>1. Build Configuration Alignment</strong></p><ul><li>Updates Maven and Gradle source/target levels</li><li>Aligns compiler plugins</li><li>Makes Java 25 usage explicit and enforceable</li></ul><p><strong>2. Deprecated and Removed API Cleanup</strong></p><p>Between Java 21 and 25, several deprecated APIs escalate from warnings to removals. OpenRewrite:</p><ul><li>Detects deprecated usage with known replacements</li><li>Applies safe substitutions</li><li>Removes constructs that no longer exist</li></ul><p>The result: future-breaking changes become <strong>controlled diffs</strong>, not surprise outages.</p><p><strong>3. Removal of Legacy Security Constructs</strong></p><p>Java’s security model continues to harden. The recipe removes:</p><ul><li>SecurityManager usage</li><li>Obsolete security hooks that no longer function meaningfully</li></ul><p>This isn’t optional cleanup — these constructs are dead weight in modern Java runtime.</p><p><strong>4. Targeted Language and I/O Modernization</strong></p><p>Where Java provides clear, safer alternatives, the recipe modernizes code:</p><ul><li>Legacy output patterns</li><li>Outdated I/O idioms</li></ul><p>Crucially, OpenRewrite only applies these changes, when the transformation is <strong>semantically unambiguous</strong>.</p><h4>Running the Java 25 Migration</h4><p><strong>1. Add the OpenRewrite Plugin</strong></p><pre>&lt;plugin&gt;<br>  &lt;groupId&gt;org.openrewrite.maven&lt;/groupId&gt;<br>  &lt;artifactId&gt;rewrite-maven-plugin&lt;/artifactId&gt;<br>  &lt;version&gt;7.24.0&lt;/version&gt;<br>  &lt;configuration&gt;<br>    &lt;activeRecipes&gt;<br>      &lt;recipe&gt;org.openrewrite.java.migrate.UpgradeToJava25&lt;/recipe&gt;<br>    &lt;/activeRecipes&gt;<br>  &lt;/configuration&gt;<br>  &lt;dependencies&gt;<br>    &lt;dependency&gt;<br>      &lt;groupId&gt;org.openrewrite.recipe&lt;/groupId&gt;<br>      &lt;artifactId&gt;rewrite-migrate-java&lt;/artifactId&gt;<br>      &lt;version&gt;latest.release&lt;/version&gt;<br>    &lt;/dependency&gt;<br>  &lt;/dependencies&gt;<br>&lt;/plugin&gt;</pre><p><strong>2. Always Run a Dry Run First, then Apply the Migration</strong></p><pre>mvn rewrite:dryRun<br><br>mvn rewrite:run<br>mvn clean compile<br>mvn test</pre><p>This should be a purely mechanical refactor commit.</p><h4>Migrating to Spring Boot 4 with OpenRewrite</h4><p>Once Java 25 migration is done, Spring Boot 4 is where OpenRewrite delivers its <strong>highest ROI</strong>. Spring Boot migrations fail less because of “one big breaking change” and more because of:</p><ul><li>Starter realignments</li><li>Property renames</li><li>Deprecated APIs</li></ul><p><strong>The Spring Boot 4 Migration Recipe</strong></p><pre>org.openrewrite.java.spring.boot4.UpgradeSpringBoot_4_0</pre><p>This recipe encodes Spring-maintained knowledge about what changed — and what must now be explicit.</p><h4>What the Boot 4 Recipe Handles</h4><p><strong>1. Build and Dependency Graph Alignment</strong></p><ul><li>Upgrades Boot dependencies to 4.0.x</li><li>Aligns Maven/Gradle plugins</li><li>Fixes BOM and dependencyManagement drift</li></ul><p>No half-upgraded builds. No silent mismatches.</p><p><strong>2. Configuration Property Migration</strong></p><ul><li>Renames deprecated properties</li><li>Removes properties that no longer exist</li><li>Updates paths where semantics changed</li></ul><p><strong>3. Modular Starter Migration</strong></p><p>Spring Boot 4 continues the push toward <strong>explicit starters</strong>:</p><ul><li>Monolithic starters → modular ones</li><li>Removal of unused transitive dependencies</li><li>OAuth2 consolidation under security namespaces</li></ul><p>The result is a <strong>smaller, clearer classpath</strong> and fewer accidental dependencies.</p><p><strong>4. Deprecated API and Test Pattern Cleanup</strong></p><p>The recipe removes outdated Boot 3.x patterns, including:</p><ul><li>Deprecated test annotations</li><li>APIs that no longer behave correctly</li></ul><p>You don’t carry dead patterns into Spring Boot 4.</p><h4>Running the Spring Boot 4 Migration</h4><pre>mvn rewrite:dryRun<br><br>mvn rewrite:run<br>mvn clean compile<br>mvn test</pre><p>As before: one mechanical commit, nothing else.</p><h4>Recommended Migration Order</h4><p>Sequencing matters:</p><ol><li>Java 21 → 25</li><li>Tests</li><li>Application starts</li><li>Run Spring Boot 4 OpenRewrite recipe</li><li>Re-test</li><li>Validate runtime behavior</li><li>Canary → rollout</li></ol><p>When something breaks, you’ll know <em>why</em>.</p><h4>Final Takeaways</h4><p>OpenRewrite doesn’t replace testing, observability or engineering judgment. It replaces <strong>weeks of mechanical migration toil</strong> with deterministic automation.</p><p>For teams running multiple services or long-lived monoliths, that’s the difference between:</p><ul><li>“We’ll upgrade someday”</li><li>“We upgraded last sprint”</li></ul><p>The recipes exist.<br>The tooling is mature.<br>The technical debt is compounding.</p><p>You can find example of changed code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=00ca79f5ecb9" width="1" height="1" alt="">

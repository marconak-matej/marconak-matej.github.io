---
layout: post
title: "[MM’s] Boot Notes — Simplifying JMS in Spring Boot 4 with the New JmsClient
  API"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-simplifying-jms-in-spring-boot-4-with-the-new-jmsclient-api-fb6b025c998d?source=rss-f1368b7746f7------2
tag:
- jms
- java
- spring-boot
- programming
- activemq
---

<h3>[MM’s] Boot Notes — Simplifying JMS in Spring Boot 4 with the new JmsClient API</h3><h4>How Spring Boot 4 Auto-Configures a Fluent, Chainable Alternative to JmsTemplate for Less Boilerplate</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2bXnlAvJWmFK4iHfBlRtaQ.jpeg" /><figcaption>Simplifying JMS in Spring Boot 4 with the new JmsClient API</figcaption></figure><p>If you’ve worked with Spring’s JMS support over the years, you know the drill: <strong>JmsTemplate </strong>handled the core messaging tasks. It handled message creation and conversion but came with some friction — verbose methods, callback patterns and multiple ways to send the same message.</p><p>While <strong>JmsTemplate </strong>still works perfectly, it reflects an older era of Spring APIs. The arrival of <strong>JdbcClient</strong> and <strong>RestClient</strong> in Spring 6.1 demonstrated a new direction — a fluent, expressive way to perform common operations without so much boilerplate.</p><p>Now, with <strong>Spring Framework 7</strong> (and <strong>Spring Boot 4</strong>), messaging joins the club. Meet <strong>JmsClient </strong>— the new fluent API for JMS.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li><strong>Spring Framework 7 </strong>introduces <strong>JmsClient</strong>, a fluent alternative to <strong>JmsTemplate</strong>.</li><li>Provides <strong>chainable APIs</strong>, <strong>consistent exception handling</strong> and <strong>modern integration</strong> with Spring’s messaging abstractions.</li><li><strong>Spring Boot 4</strong> auto-configures <strong>JmsClient</strong></li><li>Ideal for new projects looking for clean, fluent and test-friendly <strong>JMS</strong> messaging.</li></ul><h4>Introducing JmsClient: Fluent, Consistent, and Familiar</h4><p>While <strong>JmsTemplate </strong>is the classic workhorse, <strong>JmsClient </strong>serves as a modern, fluent successor to JmsMessagingTemplate, which first introduced the MessagingException model and Message&lt;?&gt; integration back in <strong>Spring 4.1</strong>. <strong>JmsClient </strong>adopts these benefits into the new fluent builder pattern. <strong>JmsClient </strong>is the evolution of <strong>Spring</strong>’s <strong>JMS</strong> abstraction.</p><h4>What’s New</h4><ul><li><strong>Fluent API design</strong> — operations like send(), receive(), and withTimeToLive() chain naturally.</li><li><strong>Unified exception model</strong> — throws MessagingException instead of JmsException.</li><li><strong>Integration with spring-messaging</strong> — works seamlessly with Message&lt;?&gt; and MessageConverter.</li><li><strong>Auto-configuration in Spring Boot 4</strong> — just inject and use it.</li></ul><p><strong>Under the Hood:</strong></p><ul><li><strong>JmsClient</strong> delegates to <strong>JmsTemplate</strong> for actual <strong>JMS</strong> operations</li><li>Provides a fluent facade over the proven <strong>JmsTemplate</strong> infrastructure</li><li>Reuses Spring’s existing message conversion and connection management.</li><li><strong>No performance penalty</strong> — same underlying implementation, better API</li></ul><p>Here’s a simple example:</p><pre>client.destination(&quot;queue&quot;)<br>      .withTimeToLive(5000)<br>      .send(&quot;Hello, JMS from JMS Client!&quot;);</pre><p>Clean, readable and aligned with the same design philosophy behind <strong>JdbcClient</strong> and <strong>RestClient</strong>.</p><h4>From JmsTemplate to JmsClient — The Evolution</h4><p>Let’s look at how message sending changes between the old and new APIs.</p><p><strong>Traditional JmsTemplate</strong></p><pre>@Service<br>public class MessageService {<br>    private final JmsTemplate jmsTemplate;<br>    // ...<br>    public void sendMessage(String destination, String message) {<br>        jmsTemplate.convertAndSend(destination, message);<br>    }<br>}</pre><p><strong>Modern JmsClient</strong></p><pre>@Service<br>public class DemoService {<br>    private final JmsClient client;<br>    private final DemoProperties properties;<br>    // ...<br>    public void sendMessage(Demo message) {<br>        client.destination(properties.queue())<br>              .send(message.message());<br>    }<br>}</pre><p>Same intent, less boilerplate. The <strong>JmsClient </strong>interface focuses on <strong>operation flow</strong>, not on callback mechanics or session management.</p><p><strong>Key Differences at a Glance</strong></p><p><strong>API Style</strong></p><ul><li><em>JmsTemplate</em>: Uses <strong>method overloading</strong></li><li><em>JmsClient</em>: Uses <strong>fluent chaining</strong></li></ul><p><strong>Exception Model</strong></p><ul><li><em>JmsTemplate</em>: Throws <strong>JmsException</strong></li><li><em>JmsClient</em>: Throws <strong>MessagingException</strong></li></ul><p><strong>Message Building</strong></p><ul><li><em>JmsTemplate</em>: Relies on <strong>callback patterns</strong></li><li><em>JmsClient</em>: Supports <strong>direct building</strong> or <strong>Message&lt;?&gt;</strong></li></ul><p><strong>Configuration</strong></p><ul><li><em>JmsTemplate</em>: Uses <strong>bean properties</strong></li><li><em>JmsClient</em>: Uses a <strong>builder pattern</strong></li></ul><p><strong>Message Integration</strong></p><ul><li><em>JmsTemplate</em>: Requires <strong>JmsMessagingTemplate</strong> for Message&lt;?&gt; support</li><li><em>JmsClient</em>: Has <strong>built-in Message&lt;?&gt; support</strong></li></ul><h4>Why It Matters</h4><p><strong>1. Fluent and Consistent API</strong></p><p>No more juggling overloaded send methods or configuration setters. Everything flows naturally:</p><pre>client.destination(&quot;demo.queue&quot;)<br>      .withTimeToLive(5000)<br>      .withHeaders(Map.of(&quot;id&quot;, &quot;1&quot;))<br>      .send(order);</pre><p>Each chained method describes message context — easy to read, easy to maintain.</p><p><strong>2. Unified Exception Handling</strong></p><p>All <strong>JmsClient </strong>operations throw MessagingException, aligning <strong>JMS</strong> with Spring’s other messaging technologies (<strong>AMQP</strong>, <strong>Kafka</strong>, <strong>WebSocket</strong>). No need to switch between exception hierarchies across modules.</p><p><strong>3. Easy Testing in Spring Boot 4</strong></p><p>The test uses an <strong>embedded broker</strong> and <strong>@</strong>MockitoSpyBean to verify message delivery end-to-end.</p><pre>@SpringBootTest<br>class DemoServiceTest {<br>    @Autowired<br>    private DemoService service;<br>    @MockitoSpyBean<br>    private DemoConsumer consumer;<br>    @Test<br>    void testSendMessage() {<br>        service.sendMessage(new Demo(&quot;Hello from JmsClient test!&quot;));<br>        verify(consumer, times(1)).receiveMessage(&quot;Hello from JmsClient test!&quot;);<br>    }<br>}</pre><h4>Quick Setup: JMS in Spring Boot 4</h4><p><strong>Spring Boot 4</strong> auto-configures <strong>JMS</strong> infrastructure. Example for both <strong>ActiveMQ Classic</strong> or <strong>Artemis.</strong></p><p><strong>Dependencies:</strong></p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-artemis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;<br>    &lt;artifactId&gt;artemis-jakarta-server&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p><strong>Configuration:</strong></p><pre>spring.artemis.mode=embedded<br>spring.artemis.embedded.persistent=false<br>spring.artemis.embedded.queues=demo-queue<br>mm.demo.queue=demo-queue<br>logging.level.org.apache.activemq.audit=OFF</pre><p>And you’re ready to use <strong>JmsClient</strong>:</p><pre>@Component<br>public class Producer {<br>    private final JmsClient client;<br>    public Producer(JmsClient client) {<br>        this.client = client;<br>    }<br>    public void send(String payload) {<br>        client.destination(&quot;demo-queue&quot;).send(payload);<br>    }<br>}</pre><p><strong>Spring Boot</strong> auto-configures everything — ConnectionFactory, MessageConverter and even the default listener factory for @JmsListener.</p><p><strong>JmsClient</strong> integrates seamlessly with <strong>Spring</strong>’s <strong>MessageConverter</strong> infrastructure for automatic payload conversion. <strong>Spring Boot</strong> auto-configures JSON conversion when <strong>Jackson</strong> is on the classpath.</p><pre>client.destination(&quot;demo-order&quot;)<br>      .send(new Order(&quot;12345&quot;, &quot;Order&quot;));<br><br>// Receive and convert back to object<br>var order = client.destination(&quot;demo-order&quot;)<br>                               .withReceiveTimeout(2000)<br>                               .receive(Order.class);</pre><p>Or you can customize the auto-configured<strong> JmsClient</strong></p><pre>@Bean<br>public MessageConverter jacksonJmsMessageConverter() {<br>    MappingJackson2MessageConverter converter = <br>        new MappingJackson2MessageConverter();<br>    converter.setTargetType(MessageType.TEXT);<br>    converter.setTypeIdPropertyName(&quot;_type&quot;);<br>    return converter;<br>}<br><br>@Bean<br>public JmsClient customJmsClient(ConnectionFactory connectionFactory) {<br>    return JmsClient.builder(connectionFactory)<br>        .messageConverter(jacksonJmsMessageConverter())<br>        .messagePostProcessor(auditingProcessor())<br>        .build();<br>}</pre><h4>Advanced Usage Highlights</h4><p><strong>Receiving Messages</strong></p><pre>var message = client.destination(&quot;my-queue&quot;)<br>                       .withReceiveTimeout(2000)<br>                       .receive(String.class);</pre><p><strong>Custom Headers</strong></p><pre>client.destination(&quot;demo-queue&quot;)<br>      .withHeaders(Map.of(&quot;tracking-id&quot;, &quot;abc123&quot;))<br>      .send(&quot;Tracking record&quot;);</pre><p><strong>Sending Message Objects</strong></p><pre>var msg = MessageBuilder.withPayload(&quot;Hello&quot;)<br>                                    .setHeader(&quot;priority&quot;, 5)<br>                                    .build();<br>client.destination(&quot;priority-queue&quot;).send(msg);</pre><p><strong>Message Interception</strong></p><p>Need to add headers to every outgoing message? Use a MessagePostProcessor:</p><pre>var client = JmsClient.builder(connectionFactory)<br>    .messagePostProcessor(m -&gt; MessageBuilder.fromMessage(m)<br>        .setHeader(&quot;id&quot;, &quot;1&quot;)<br>        .build())<br>    .build();</pre><h4>Migration Guide: JmsTemplate → JmsClient</h4><p>The transition path is intentionally simple.</p><p><strong>Before:</strong></p><pre>jmsTemplate.convertAndSend(&quot;demo-queue&quot;, demo);</pre><p><strong>After:</strong></p><pre>client.destination(&quot;demo-queue&quot;).send(demo);</pre><p><strong>Current Limitations</strong></p><p>While <strong>JmsClient</strong> covers most common use cases, some scenarios still require <strong>JmsTemplate</strong>:</p><ul><li>Complex session management requiring direct Session access</li><li>Custom message creation beyond MessageConverter</li><li>Specific <strong>JMS</strong> provider features not exposed in the fluent API</li></ul><p>You can even use both APIs side-by-side while modernizing gradually — <strong>Spring Framework 7</strong> supports both.</p><h4>When to Choose JmsClient</h4><p>Use <strong>JmsClient </strong>when:</p><ul><li>Starting a new <strong>Spring Boot 4</strong> project</li><li>You prefer fluent, readable APIs</li><li>You need unified MessagingException semantics</li><li>You’re already familiar with <strong>JdbcClient</strong> or <strong>RestClient</strong></li></ul><p>Keep <strong>JmsTemplate </strong>when:</p><ul><li>Maintaining large legacy systems</li><li>Needing low-level JMS features not yet exposed in <strong>JmsClient</strong></li><li>Your team’s tooling or frameworks depend on <strong>JmsTemplate</strong></li></ul><h4>Final Takeaways</h4><p><strong>Spring</strong> <strong>Framework 7</strong>’s <strong>JmsClient</strong> signals the future of messaging in the <strong>Spring</strong> ecosystem. By adopting a fluent design, unified exceptions, and <strong>Spring Boot</strong> <strong>4</strong> auto-configuration, <strong>JMS</strong> development feels once again modern and consistent with the rest of <strong>Spring</strong>’s client stack.</p><p><strong>Key things to remember:</strong></p><ul><li><strong>JmsClient</strong> — less boilerplate, more readability</li><li><strong>Spring Boot 4 </strong>— simpler JMS setup, better testing</li><li>Migration — drop-in and incremental</li></ul><p>If your next service involves message queues or event-driven processing, start with<strong> JmsClient</strong> — it’s the cleanest, most elegant way to handle <strong>JMS</strong> in <strong>Spring</strong> yet.</p><p>You can find all the code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fb6b025c998d" width="1" height="1" alt="">

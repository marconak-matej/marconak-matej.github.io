---
layout: post
title: "[MM’s] Boot Notes — Spring Boot 4"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-spring-boot-4-95badef7f3e2?source=rss-f1368b7746f7------2
tag:
- spring-boot
- spring
- programming
- java
---

<h3>[MM’s] Boot Notes — Spring Boot 4</h3><h4>The Next Generation of Modern Java Services</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*tEFuFZATHuuHewbjR64oYg.png" /><figcaption>Spring Boot 4 — The Next Generation of Modern Java Services</figcaption></figure><p>Every few years, Spring delivers a release that quietly resets the foundation of enterprise Java development. Spring Boot 4.0 — built on top of Spring Framework 7 — is exactly that kind of release. It’s not just an upgrade; it’s a modernization of the entire development model: modularized starters, native API versioning, declarative HTTP clients, built-in resilience, JSpecify null-safety and first-class support for Java 25.</p><p>If you’ve been using Spring Boot 3.x, you’ll feel at home. But look closer and you’ll notice the framework has become leaner, more explicit, and better aligned with how teams build microservices today.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li><strong>Modularized Boot</strong> → Precise, smaller modules replace monolithic starters.</li><li><strong>API Versioning</strong> → Native, annotation-based version routing without custom filters.</li><li><strong>HTTP Service Clients</strong> → Declarative, Feign-like interfaces powered by Spring’s @HttpExchange.</li><li><strong>First-party Resilience</strong> → @Retryable, @ConcurrencyLimit and retry templates built directly into Spring Framework.</li><li><strong>JSpecify Null Safety</strong> → Portfolio-wide null-safety with modern, tool-friendly annotations.</li><li><strong>Java 25 &amp; Jackson 3</strong> → Full support for the newest JVM and JSON stack while keeping Java 17 compatibility.</li></ul><h4>Why Spring Boot 4 Matters Right Now</h4><p>Spring Boot 3.x brought major changes — Jakarta EE 10, virtual threads, observability — but remained constrained by older assumptions: large starters, custom API versioning patterns and resilience handled by external libraries.</p><p><strong>Spring Boot 4</strong> tackles these at the architectural level:</p><ul><li>Clean module boundaries</li><li>Explicit null-safety</li><li>Native versioning across MVC, WebFlux, clients and tests</li><li>Modern client APIs for HTTP, JDBC, JMS</li><li>Consistent infrastructure for large, service-heavy systems</li></ul><p>The release aligns Spring Boot with modern Java expectations: composable, type-safe, tuned for both JVM and native image deployments.</p><h4>1. Modularization: Boot Becomes Lean and Precise</h4><p>Classic starters often pulled in more than teams needed. “Starter bloat” wasn’t dramatic, but it made container images heavier and dependency trees noisy.</p><p><strong>The Spring Boot 4 approach</strong></p><p>Spring Boot 4 introduces <strong>complete modularization</strong> across 70+ modules. Every technology now has:</p><ul><li>a main module</li><li>a dedicated starter</li><li>a dedicated test starter</li></ul><pre>&lt;!-- Old --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br><br>&lt;!-- New --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-webmvc&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jackson&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p><strong>Why it matters</strong></p><ul><li>Faster container builds</li><li>Smaller runtime footprint</li><li>Clearer dependency graphs</li><li>Better test isolation</li><li>More predictable auto-configuration</li></ul><p>For teams upgrading gradually, Spring Boot provides <strong>classic starters</strong> (spring-boot-starter-classic and spring-boot-starter-test-classic) to preserve older behavior while you transition.</p><h4>2. Native API Versioning: Declarative, Clear, Zero Boilerplate</h4><p>API versioning has historically been one of the most DIY aspects of Spring development. Spring Framework 7 introduces <strong>native, annotation-based versioning</strong>:</p><pre>@RestController<br>@RequestMapping(&quot;/api/products&quot;)<br>public class ProductController {<br>    @GetMapping(path = &quot;/{id}&quot;, version = &quot;1.0&quot;)<br>    ProductV1 getV1(@PathVariable String id) { ... }<br>    @GetMapping(path = &quot;/{id}&quot;, version = &quot;2.0&quot;)<br>    ProductV2 getV2(@PathVariable String id) { ... }<br>}</pre><p><strong>Select your strategy via properties</strong></p><pre># Option A: Header-based<br>spring.mvc.apiversion.use.header=API-Version<br># Option B: Query parameter<br>spring.mvc.apiversion.use.query-param=version<br># Option C: Path segment<br>spring.mvc.apiversion.use.path-segment=true</pre><p><strong>Baseline versions</strong></p><p>A powerful addition:</p><pre>@GetMapping(version = &quot;1.1+&quot;)</pre><p>…matches versions <strong>≥ 1.1</strong> unless a more specific mapping exists.</p><p><strong>End-to-end support</strong></p><p>Versioning is also integrated into:</p><ul><li>RestClient</li><li>WebClient</li><li>HTTP interface clients</li><li>MockMvc &amp; WebTestClient</li></ul><pre>var client = RestClient.builder()<br>    .apiVersionInserter(ApiVersionInserter.useHeader(&quot;API-Version&quot;))<br>    .build();<br>client.get()<br>      .uri(&quot;/api/products/123&quot;)<br>      .apiVersion(&quot;2.0&quot;)<br>      .retrieve()<br>      .body(ProductV2.class);</pre><p>This is one of the most impactful quality-of-life improvements in Spring in years.</p><h4>3. HTTP Service Clients: Declarative HTTP Without Feign</h4><p>RestTemplate is deprecated (officially in 7.1), WebClient is powerful, but verbose and many teams brought Feign into the stack for simplicity.</p><p>Spring Framework introduces <strong>HTTP Service Client Enhancements</strong> — a declarative interface-based API:</p><pre>@HttpExchange(url = &quot;https://api.example.com&quot;)<br>public interface ProductService {<br>    @GetExchange(&quot;/products&quot;)<br>    List&lt;Product&gt; getAllProducts();<br>    @GetExchange(&quot;/products/{id}&quot;)<br>    Product get(@PathVariable String id);<br>    @PostExchange(&quot;/products&quot;)<br>    Product create(@RequestBody Product product);<br>}</pre><p><strong>Register multiple interfaces at once</strong></p><pre>@Configuration<br>@ImportHttpServices(<br>    group = &quot;external&quot;,<br>    types = {ProductService.class, OrderService.class}<br>)<br>class HttpServicesConfig extends AbstractHttpServiceRegistrar {<br>    @Bean<br>    RestClientHttpServiceGroupConfigurer groupConfigurer() {<br>        return groups -&gt; groups.filterByName(&quot;external&quot;)<br>            .configureClient((group, builder) -&gt;<br>                builder.defaultHeader(&quot;User-Agent&quot;, &quot;My-App&quot;));<br>    }<br>}</pre><p><strong>Why this matters</strong></p><ul><li>Zero boilerplate client creation</li><li>Native Spring integration</li><li>Group-level configuration</li><li>Works with RestClient &amp; WebClient</li><li>No external Feign dependency</li></ul><h4>4. Built-In Resilience: Retries and Concurrency Limits Without Extra Libraries</h4><p>For years, most Spring users relied on <strong>Spring Retry</strong> or <strong>Resilience4j</strong> for retry logic.</p><p>In Spring Framework 7, resilience is now first-party.</p><p><strong>Annotated methods</strong></p><pre>@Service<br>public class ExternalApiService {<br>    @Retryable(<br>        includes = GatewayTimeoutException.class,<br>        maxRetries = 4,<br>        multiplier = 2.0<br>    )<br>    @ConcurrencyLimit(15)<br>    public ApiResponse callExternal(String key) {<br>        return client.get(key);<br>    }<br>}</pre><p><strong>Programmatic alternative</strong></p><pre>var policy = RetryPolicy.builder()<br>    .includes(GatewayTimeoutException.class)<br>    .maxRetries(4)<br>    .delay(Duration.ofMillis(200))<br>    .build();<br>var template = new RetryTemplate(policy);<br>return template.execute(() -&gt; client.get(key));</pre><p><strong>Reactive support</strong></p><p>If the return type is reactive, the retry logic automatically decorates the Reactor pipeline.</p><p><strong>When to use what</strong>:</p><ul><li><strong>Built-in Spring resilience</strong> → Most apps (simple retries, limits)</li><li><strong>Resilience4j</strong> → Circuit breakers, rate limiting, bulkheads</li></ul><h4>5. JSpecify Null Safety: A Modern, Tool-Friendly Type System</h4><p>Spring has fully migrated from JSR-305 to <strong>JSpecify</strong> annotations.<br> This brings:</p><ul><li>Better Kotlin alignment</li><li>Full generic/vararg/array support</li><li>Precise nullability contracts</li><li>IDE + static analysis improvements</li></ul><pre>@NonNull<br>List&lt;@Nullable String&gt; items;</pre><p>Kotlin users especially benefit: API nullability is now accurately inferred. This change appears small, but it dramatically reduces subtle bugs across large codebases.</p><h4>6. JmsClient: A Modern Client API for Messaging</h4><p>After RestClient and JdbcClient, messaging now gets the same treatment.</p><pre>@Service<br>public class OrderMessaging {<br>    private final JmsClient jms;<br>    public void sendOrder(Order order) {<br>        jms.send(&quot;orders.queue&quot;)<br>           .withPayload(order)<br>           .execute();<br>    }<br>    public Order receiveOrder() {<br>        return jms.receive(&quot;orders.queue&quot;)<br>                  .asType(Order.class);<br>    }<br>}</pre><p>It’s simpler and more discoverable than JmsTemplate and aligns with Spring’s modern fluent client APIs.</p><h4>Other Noteworthy Changes in Spring Boot 4 and Spring Framework 7</h4><p><strong>Major dependency upgrades</strong></p><ul><li><strong>Jackson 3</strong> (with Jackson 2 compatibility mode available)</li><li><strong>Hibernate ORM 7.1/7.2</strong> with JPA 3.2</li><li><strong>Servlet 6.1 baseline</strong> → Tomcat 11, Jetty 12.1</li><li><strong>Kotlin 2.2</strong></li><li><strong>GraalVM 25</strong> (new exact reachability metadata format)</li></ul><p><strong>Removals</strong></p><ul><li>Undertow support</li><li>All javax.* annotations</li><li>Spock integration (due to Groovy 5)</li><li>Executable Uber-JAR launch scripts</li><li>Several deprecated Boot 3.x APIs</li></ul><p><strong>Testing improvements</strong></p><ul><li>RestTestClient (non-reactive equivalent of WebTestClient)</li><li>Better @Nested test class injection</li><li>Dedicated test starters for every technology</li></ul><p><strong>Configuration changes</strong></p><ul><li>Many MongoDB properties renamed</li><li>HttpMessageConverters is deprecated in favor of Spring Framework 7’s improved support</li><li>Tracing properties updated</li></ul><h4>Migration Guide: A Practical Path Forward</h4><p>Upgrading to Boot 4 sounds big — but the migration path is smooth:</p><p><strong>1. Upgrade to Spring Boot 3.5.x first</strong></p><p>This ensures you’re on the correct baseline.</p><p><strong>2. Remove deprecated APIs</strong></p><p>Anything deprecated in 3.x is removed in 4.0.</p><p><strong>3. Switch to classic starters</strong></p><p>Temporarily use:</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-classic&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>Then gradually replace with the new modular starters.</p><p><strong>4. Migrate </strong><strong>javax.* → </strong><strong>jakarta.*</strong></p><p>If you haven’t already.</p><p><strong>5. Adopt JSpecify</strong></p><p>Update nullability imports if needed.</p><p><strong>6. Move to HTTP Service Clients &amp; native API versioning</strong></p><p>Highly recommended for new services.</p><h4>Final Takeaways</h4><p>Spring Boot 4 marks the beginning of a new generation for the Spring ecosystem. It’s lighter, more explicit, more modular and better aligned with the practices modern teams rely on.</p><p>If you’re starting a new service:<br> → <strong>Start with Boot 4</strong>. You’ll get versioning, declarative clients, modern resilience and type safety out of the box.</p><p>If you’re maintaining existing systems:<br> → <strong>Upgrade gradually</strong>. Use classic starters, follow the migration guide and adopt new modules at your own pace.</p><p>If you’re working across multiple microservices:<br> → <strong>Group your HTTP clients</strong>, version your APIs natively and reduce the amount of custom wiring you maintain.</p><p>Spring Boot 4 is not a radical rewrite — it’s the framework evolving gracefully without breaking the familiar Spring development experience.</p><p>You can find an example of how to use Spring Boot 4 on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=95badef7f3e2" width="1" height="1" alt="">

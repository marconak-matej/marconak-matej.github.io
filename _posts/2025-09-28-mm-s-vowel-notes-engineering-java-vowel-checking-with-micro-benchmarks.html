---
layout: post
title: "[MM’s] Vowel Notes — Engineering Java vowel-checking with micro-benchmarks"
canonical_url: https://marconak-matej.medium.com/mms-vowel-notes-engineering-java-vowel-checking-with-micro-benchmarks-bf2e313766b1?source=rss-f1368b7746f7------2
tag:
- software-engineering
- performance
- testing
- case-study
- java
---

<h3>[MM’s] Vowel Notes — Engineering Java vowel-checking with micro-benchmarks</h3><h4>Exploring the trade-offs between readability and raw speed for detecting a vowel in a string.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*reeqs5Am5Q7DGFICA5I92g.png" /><figcaption>Vowel Notes — Engineering Java vowel-checking with micro-benchmarks</figcaption></figure><p>Inspired by Austin Henley’s exploration of vowels —<a href="https://austinhenley.com/blog/vowels.html"> The fastest way to detect a vowel in a string</a>, this post brings the concept to Java. Vowels may be small, but detecting them efficiently can reveal a lot about string processing in Java.</p><p>We’ll walk through multiple approaches — from classic loops to modern streams — and measure their performance with micro-benchmarks. Whether you’re optimizing for speed or clarity, there’s something here for every Java developer.</p><h3>The Classics: Loop-Based Approaches</h3><p>These methods are fundamental, easy to reason about and a great starting point.</p><h4>1. Simple Loop with Character Check</h4><p>This is the most direct and explicit way to solve the problem.</p><pre>public boolean hasVowels(String text) {<br>    for (var c : text.toCharArray()) {<br>        if (c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39; ||<br>            c == &#39;A&#39; || c == &#39;E&#39; || c == &#39;I&#39; || c == &#39;O&#39; || c == &#39;U&#39;) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It iterates through each character and uses a series of OR (||) conditions to check against a hard-coded list of vowels.</li><li><strong>Pros:</strong> Extremely easy for beginners to understand.</li><li><strong>Cons:</strong> Verbose and less maintainable.</li></ul><h4>2. Loop with String.indexOf()</h4><p>A small refinement that makes our vowel list much easier to manage.</p><pre>private static final String VOWELS = &quot;aeiouAEIOU&quot;;<br>public boolean hasVowels(String text) {<br>    for (var c : text.toCharArray()) {<br>        if (VOWELS.indexOf(c) != -1) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> The vowels are stored in a single String. The indexOf() method quickly checks if a character exists within that string.</li><li><strong>Pros:</strong> Centralizes the vowel definition, making it clean, maintainable and readable.</li><li><strong>Cons:</strong> String.indexOf() isn&#39;t the most performant lookup method for a single character.</li></ul><h3>The Modern Way: Stream-Based Approach</h3><p>Leveraging Java 8+ features, this approach is more declarative and functional.</p><h4>3. anyMatch with a Set</h4><p>This is an elegant and efficient solution that combines the power of Streams with the performance of a Set.</p><pre>private static final Set&lt;Character&gt; VOWELS = Set.of(&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;,<br>                                                   &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;);<br>public boolean hasVowels(String text) {<br>    return text.chars()<br>            .mapToObj(ch -&gt; (char) ch)<br>            .anyMatch(VOWELS::contains);<br>}</pre><ul><li><strong>How it works:</strong> It converts the string into a stream of characters. anyMatch is a short-circuiting operation that stops as soon as it finds a character contained in the VOWELS set.</li><li><strong>Pros:</strong> Clean, expressive one-liner. A Set provides a very fast <strong>O(1)</strong> average lookup time.</li><li><strong>Cons:</strong> Can have a minor overhead for creating streams, which might be noticeable on extremely small strings in a tight loop.</li></ul><h3>For Maximum Performance: Low-Level Techniques</h3><p>When every microsecond counts, these low-level approaches offer unparalleled speed.</p><h4>4. BitSet Implementation</h4><p>A BitSet is a memory-efficient data structure that uses bits as flags, providing a great balance of speed and usability.</p><pre>private static final BitSet VOWELS = new BitSet(128);<br>static {<br>    VOWELS.set(&#39;a&#39;); VOWELS.set(&#39;e&#39;); VOWELS.set(&#39;i&#39;); VOWELS.set(&#39;o&#39;); VOWELS.set(&#39;u&#39;);<br>    VOWELS.set(&#39;A&#39;); VOWELS.set(&#39;E&#39;); VOWELS.set(&#39;I&#39;); VOWELS.set(&#39;O&#39;); VOWELS.set(&#39;U&#39;);<br>}<br>public boolean hasVowels(String text) {<br>    for (var i = 0; i &lt; text.length(); i++) {<br>        if (VOWELS.get(text.charAt(i))) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It uses a BitSet where each character&#39;s ASCII value corresponds to a bit. If the bit is 1 (true), it&#39;s a vowel.</li><li><strong>Pros:</strong> Extremely fast <strong>O(1)</strong> lookup and very memory efficient. More readable than manual bit masking.</li><li><strong>Cons:</strong> Primarily suited for character sets like ASCII where characters map cleanly to small integer indices.</li></ul><h4>5. Byte Mask Implementation</h4><p>This is the most “metal” you can get. It uses raw bit-wise operations for the fastest possible check.</p><pre>private static final long LOWERCASE_MASK = (1L &lt;&lt; (&#39;a&#39; - 97)) | (1L &lt;&lt; (&#39;e&#39; - 97)) |<br>        (1L &lt;&lt; (&#39;i&#39; - 97)) | (1L &lt;&lt; (&#39;o&#39; - 97)) | (1L &lt;&lt; (&#39;u&#39; - 97));<br>private static final long UPPERCASE_MASK = (1L &lt;&lt; (&#39;A&#39; - 65)) | (1L &lt;&lt; (&#39;E&#39; - 65)) |<br>        (1L &lt;&lt; (&#39;I&#39; - 65)) | (1L &lt;&lt; (&#39;O&#39; - 65)) | (1L &lt;&lt; (&#39;U&#39; - 65));<br>public boolean hasVowels(String text) {<br>    for (var i = 0; i &lt; text.length(); i++) {<br>        var c = text.charAt(i);<br>        if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {<br>            if ((LOWERCASE_MASK &amp; (1L &lt;&lt; (c - 97))) != 0) return true;<br>        } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {<br>            if ((UPPERCASE_MASK &amp; (1L &lt;&lt; (c - 65))) != 0) return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> A long is used as a bit-mask where each bit represents a letter of the alphabet. A bit-wise AND operation checks if a character&#39;s corresponding bit is set.</li><li><strong>Pros:</strong> The absolute fastest method. Minimal memory usage.</li><li><strong>Cons:</strong> Very poor readability. This is “clever” code that is hard to maintain.</li></ul><h3>The Pragmatic Performer: Array-Based Lookup</h3><p>This technique offers a fantastic compromise, delivering top-tier performance with code that’s still easy to follow.</p><h4>6. Boolean Array</h4><p>This creates a simple lookup table, using a character’s integer value as an index for a near-instant check.</p><pre>private static final boolean[] VOWELS = new boolean[128];<br>static {<br>    for (var c : new char[]{&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;}) {<br>        VOWELS[c] = true;<br>    }<br>}<br>public boolean hasVowels(String text) {<br>    for (var i = 0; i &lt; text.length(); i++) {<br>        var c = text.charAt(i);<br>        if (c &lt; 128 &amp;&amp; VOWELS[c]) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> An array of 128 boolean is created (for ASCII). The indices corresponding to vowel characters are set to true.</li><li><strong>Pros:</strong> Blazing fast <strong>O(1)</strong> lookup. Conceptually simple and very effective.</li><li><strong>Cons:</strong> Uses a fixed block of memory and is limited to the character set defined by the array size (e.g., ASCII).</li></ul><h3>Built-in String Operations</h3><p>These methods rely on familiar String class methods.</p><h4>7. String.contains()</h4><pre>private static final String VOWELS = &quot;aeiouAEIOU&quot;;<br>public boolean hasVowels(String text) {<br>    for (var vowel : VOWELS.toCharArray()) {<br>        if (text.contains(String.valueOf(vowel))) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It loops through each <em>vowel</em> and checks if the <em>entire input string</em> contains it.</li><li><strong>Pros:</strong> Very easy to write and understand.</li><li><strong>Cons:</strong> Extremely inefficient. Each call to .contains() can re-scan the entire input string.</li></ul><h4>8. String.replace()</h4><p>A creative but impractical approach that demonstrates string manipulation.</p><pre>public boolean hasVowels(String text) {<br>    var current = text;<br>    var originalLength = text.length();    <br>    for (char vowel : &quot;aeiouAEIOU&quot;.toCharArray()) {<br>        current = current.replace(String.valueOf(vowel), &quot;&quot;);<br>        if (current.length() != originalLength) return true;<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It tries to replace each vowel with an empty string. If the string length changes at any point, a vowel must have been present.</li><li><strong>Pros:</strong> A unique way to think about the problem.</li><li><strong>Cons:</strong> Very inefficient due to the creation of new string objects in a loop.</li></ul><h3>The Power of Patterns: Regex-Based Implementations</h3><p>Regular expressions are the ultimate tool for pattern matching in text.</p><h4>9. Simple Regex find()</h4><p>A concise and powerful way to solve the problem using a pattern.</p><pre>private static final Pattern VOWEL_PATTERN = Pattern.compile(&quot;[aeiouAEIOU]&quot;);<br>public boolean hasVowels(String text) {<br>    return VOWEL_PATTERN.matcher(text).find();<br>}</pre><ul><li><strong>How it works:</strong> A Pattern object is compiled once to represent &quot;any character in this set.&quot; The matcher(text).find() method then efficiently searches the string for the first occurrence.</li><li><strong>Pros:</strong> Clean, highly readable, and easily extensible for more complex patterns.</li><li><strong>Cons:</strong> Regex engines carry some overhead, so this may not be as fast as direct array or bit-set lookup for this simple task.</li></ul><h4>10. Regex replaceAll()</h4><p>Another regex-based approach that works by removing all matches.</p><pre>private static final String VOWELS_MATCH = &quot;[aeiouAEIOU]&quot;;<br>public boolean hasVowels(String text) {<br>    var withoutVowels = text.replaceAll(VOWELS_MATCH, &quot;&quot;);<br>    return withoutVowels.length() != text.length();<br>}</pre><ul><li><strong>How it works:</strong> It replaces all vowels in the string with nothing and then checks if the string’s length has changed.</li><li><strong>Pros:</strong> Declarative and easy to understand what it’s doing.</li><li><strong>Cons:</strong> Inefficient because it processes the <em>entire</em> string and creates a new one, even if the first character is a vowel.</li></ul><h3>Benchmark</h3><p>To objectively compare these Java vowel-checking methods, we’re using the <a href="https://github.com/openjdk/jmh"><strong>Java Microbenchmark Harness (JMH)</strong></a>.</p><pre>@BenchmarkMode(Mode.AverageTime)<br>@OutputTimeUnit(TimeUnit.NANOSECONDS)<br>@State(Scope.Benchmark)<br>@Fork(value = 2, warmups = 1)<br>@Warmup(iterations = 5, time = 1)<br>@Measurement(iterations = 10, time = 1)<br>public class VowelCheckerBenchmark {</pre><p>The benchmarks were run on <strong>OpenJDK 25</strong> (Temurin-25+36) with -Xms1g -Xmx1g -XX:+UseG1GC. It measures the <strong>average execution time per operation in nanoseconds</strong>, running in a <strong>shared benchmark state</strong>, with <strong>2 forks (each doing 1 warmup fork)</strong>, <strong>warming up for 5 iterations of 1 second</strong> each, and then measuring <strong>over 10 iterations of 1 second each</strong>.</p><pre><br>| Method           | withVowels (ns/op) | withoutVowels (ns/op) |<br>|------------------|--------------------|-----------------------|<br>| anyMatchContains | 30.301             | 858.955               |<br>| anyMatch         | 12.123             | 490.683               |<br>| bitSet           | 🟢 **1.481**       | 64.707                |<br>| byteMask         | 🟢 **1.297**       | 69.118                |<br>| charArray        | 🟢 **1.296**       | 🟢 **54.632**         |<br>| contains         | 15.513             | 157.358               |<br>| loopIn           | 8.972              | 211.650               |<br>| loopOr           | 8.242              | 174.308               |<br>| nestedFor        | 10.896             | 382.267               |<br>| recursion        | 1.743              | 🔴 **1555.377**       |<br>| regexReplace     | 🔴 **428.105**     | 118.510               |<br>| regex            | 14.023             | 75.144                |<br>| stringReplace    | 59.367             | 61.914                |</pre><h3>Wrapping up</h3><h4>Top performers (1–2 ns with vowels, ~55–70 ns without)</h4><ul><li>charArray → <strong>1.296 ns </strong>(best)</li><li>byteMask → <strong>1.297 ns</strong></li><li>bitSet → <strong>1.481 ns</strong></li></ul><p><strong>Without vowels:</strong></p><ul><li>charArray → <strong>54.6 ns</strong> (best)</li><li>bitSet → 64.7 ns</li><li>byteMask → 69.1 ns</li></ul><p>The <strong>lookup-based methods (</strong><strong>charArray, </strong><strong>bitSet, </strong><strong>byteMask) are clear winners</strong>:</p><ul><li>Tiny cost when vowel found early.</li><li>Linear, but still very fast when scanning fully.</li></ul><h3>Ranking summary</h3><h4>✅ Best (production-ready, fastest, stable)</h4><ul><li>charArray (fastest, simplest, predictable)</li><li>bitSet (slightly slower, but elegant)</li><li>byteMask (comparable, just more obscure)</li></ul><h4>⚖️ Acceptable (slower but usable if clarity matters)</h4><ul><li>regex (≈14 ns / 75 ns)</li><li>contains (≈15 ns / 157 ns)</li></ul><h4>⚠️ Slower (avoid for hot paths)</h4><ul><li>loopIn, loopOr, nestedFor (hundreds of ns worst case)</li></ul><h4>🐌 Worst</h4><ul><li>recursion (unstable, explodes without vowels)</li><li>regexReplace (hundreds of ns, allocates)</li><li>stringReplace (~60 ns always, wasteful)</li></ul><h3>Takeaways</h3><ul><li>The <strong>JVM</strong> is <em>very</em> good at optimizing simple array/bit-set lookup.</li><li><strong>Low-Level is King for Speed:</strong> For a simple task like vowel checking, direct array lookup (charArray) or bit-fiddling (byteMask, bitSet) are the most efficient.</li><li><strong>If you want a balance of readability + acceptable performance:</strong> regex or contains.</li><li><strong>Streams and Recursion are Costly</strong></li></ul><p>You can find all the code on <a href="https://github.com/marconak-matej/vowels">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bf2e313766b1" width="1" height="1" alt="">

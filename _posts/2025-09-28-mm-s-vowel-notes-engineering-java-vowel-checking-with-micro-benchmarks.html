---
layout: post
title: "[MMâ€™s] Vowel Notesâ€Šâ€”â€ŠEngineering Java vowel-checking with micro-benchmarks"
canonical_url: https://marconak-matej.medium.com/mms-vowel-notes-engineering-java-vowel-checking-with-micro-benchmarks-bf2e313766b1?source=rss-f1368b7746f7------2
tag:
- software-engineering
- performance
- testing
- case-study
- java
---

<h3>[MMâ€™s] Vowel Notesâ€Šâ€”â€ŠEngineering Java vowel-checking with micro-benchmarks</h3><h4>Exploring the trade-offs between readability and raw speed for detecting a vowel in aÂ string.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*reeqs5Am5Q7DGFICA5I92g.png" /><figcaption>Vowel Notesâ€Šâ€”â€ŠEngineering Java vowel-checking with micro-benchmarks</figcaption></figure><p>Inspired by Austin Henleyâ€™s exploration of vowelsâ€Šâ€”<a href="https://austinhenley.com/blog/vowels.html">â€ŠThe fastest way to detect a vowel in a string</a>, this post brings the concept to Java. Vowels may be small, but detecting them efficiently can reveal a lot about string processing inÂ Java.</p><p>Weâ€™ll walk through multiple approachesâ€Šâ€”â€Šfrom classic loops to modern streamsâ€Šâ€”â€Šand measure their performance with micro-benchmarks. Whether youâ€™re optimizing for speed or clarity, thereâ€™s something here for every Java developer.</p><h3>The Classics: Loop-Based Approaches</h3><p>These methods are fundamental, easy to reason about and a great startingÂ point.</p><h4>1. Simple Loop with Character Check</h4><p>This is the most direct and explicit way to solve theÂ problem.</p><pre>public boolean hasVowels(String text) {<br>    for (var c : text.toCharArray()) {<br>        if (c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39; ||<br>            c == &#39;A&#39; || c == &#39;E&#39; || c == &#39;I&#39; || c == &#39;O&#39; || c == &#39;U&#39;) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It iterates through each character and uses a series of OR (||) conditions to check against a hard-coded list ofÂ vowels.</li><li><strong>Pros:</strong> Extremely easy for beginners to understand.</li><li><strong>Cons:</strong> Verbose and less maintainable.</li></ul><h4>2. Loop with String.indexOf()</h4><p>A small refinement that makes our vowel list much easier toÂ manage.</p><pre>private static final String VOWELS = &quot;aeiouAEIOU&quot;;<br>public boolean hasVowels(String text) {<br>    for (var c : text.toCharArray()) {<br>        if (VOWELS.indexOf(c) != -1) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> The vowels are stored in a single String. The indexOf() method quickly checks if a character exists within thatÂ string.</li><li><strong>Pros:</strong> Centralizes the vowel definition, making it clean, maintainable and readable.</li><li><strong>Cons:</strong> String.indexOf() isn&#39;t the most performant lookup method for a single character.</li></ul><h3>The Modern Way: Stream-Based Approach</h3><p>Leveraging Java 8+ features, this approach is more declarative and functional.</p><h4>3. anyMatch with aÂ Set</h4><p>This is an elegant and efficient solution that combines the power of Streams with the performance of aÂ Set.</p><pre>private static final Set&lt;Character&gt; VOWELS = Set.of(&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;,<br>                                                   &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;);<br>public boolean hasVowels(String text) {<br>    return text.chars()<br>            .mapToObj(ch -&gt; (char) ch)<br>            .anyMatch(VOWELS::contains);<br>}</pre><ul><li><strong>How it works:</strong> It converts the string into a stream of characters. anyMatch is a short-circuiting operation that stops as soon as it finds a character contained in the VOWELSÂ set.</li><li><strong>Pros:</strong> Clean, expressive one-liner. A Set provides a very fast <strong>O(1)</strong> average lookupÂ time.</li><li><strong>Cons:</strong> Can have a minor overhead for creating streams, which might be noticeable on extremely small strings in a tightÂ loop.</li></ul><h3>For Maximum Performance: Low-Level Techniques</h3><p>When every microsecond counts, these low-level approaches offer unparalleled speed.</p><h4>4. BitSet Implementation</h4><p>A BitSet is a memory-efficient data structure that uses bits as flags, providing a great balance of speed and usability.</p><pre>private static final BitSet VOWELS = new BitSet(128);<br>static {<br>    VOWELS.set(&#39;a&#39;); VOWELS.set(&#39;e&#39;); VOWELS.set(&#39;i&#39;); VOWELS.set(&#39;o&#39;); VOWELS.set(&#39;u&#39;);<br>    VOWELS.set(&#39;A&#39;); VOWELS.set(&#39;E&#39;); VOWELS.set(&#39;I&#39;); VOWELS.set(&#39;O&#39;); VOWELS.set(&#39;U&#39;);<br>}<br>public boolean hasVowels(String text) {<br>    for (var i = 0; i &lt; text.length(); i++) {<br>        if (VOWELS.get(text.charAt(i))) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It uses a BitSet where each character&#39;s ASCII value corresponds to a bit. If the bit is 1 (true), it&#39;s aÂ vowel.</li><li><strong>Pros:</strong> Extremely fast <strong>O(1)</strong> lookup and very memory efficient. More readable than manual bitÂ masking.</li><li><strong>Cons:</strong> Primarily suited for character sets like ASCII where characters map cleanly to small integerÂ indices.</li></ul><h4>5. Byte Mask Implementation</h4><p>This is the most â€œmetalâ€ you can get. It uses raw bit-wise operations for the fastest possibleÂ check.</p><pre>private static final long LOWERCASE_MASK = (1L &lt;&lt; (&#39;a&#39; - 97)) | (1L &lt;&lt; (&#39;e&#39; - 97)) |<br>        (1L &lt;&lt; (&#39;i&#39; - 97)) | (1L &lt;&lt; (&#39;o&#39; - 97)) | (1L &lt;&lt; (&#39;u&#39; - 97));<br>private static final long UPPERCASE_MASK = (1L &lt;&lt; (&#39;A&#39; - 65)) | (1L &lt;&lt; (&#39;E&#39; - 65)) |<br>        (1L &lt;&lt; (&#39;I&#39; - 65)) | (1L &lt;&lt; (&#39;O&#39; - 65)) | (1L &lt;&lt; (&#39;U&#39; - 65));<br>public boolean hasVowels(String text) {<br>    for (var i = 0; i &lt; text.length(); i++) {<br>        var c = text.charAt(i);<br>        if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) {<br>            if ((LOWERCASE_MASK &amp; (1L &lt;&lt; (c - 97))) != 0) return true;<br>        } else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) {<br>            if ((UPPERCASE_MASK &amp; (1L &lt;&lt; (c - 65))) != 0) return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> A long is used as a bit-mask where each bit represents a letter of the alphabet. A bit-wise AND operation checks if a character&#39;s corresponding bit isÂ set.</li><li><strong>Pros:</strong> The absolute fastest method. Minimal memoryÂ usage.</li><li><strong>Cons:</strong> Very poor readability. This is â€œcleverâ€ code that is hard to maintain.</li></ul><h3>The Pragmatic Performer: Array-Based Lookup</h3><p>This technique offers a fantastic compromise, delivering top-tier performance with code thatâ€™s still easy toÂ follow.</p><h4>6. BooleanÂ Array</h4><p>This creates a simple lookup table, using a characterâ€™s integer value as an index for a near-instant check.</p><pre>private static final boolean[] VOWELS = new boolean[128];<br>static {<br>    for (var c : new char[]{&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;}) {<br>        VOWELS[c] = true;<br>    }<br>}<br>public boolean hasVowels(String text) {<br>    for (var i = 0; i &lt; text.length(); i++) {<br>        var c = text.charAt(i);<br>        if (c &lt; 128 &amp;&amp; VOWELS[c]) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> An array of 128 boolean is created (for ASCII). The indices corresponding to vowel characters are set toÂ true.</li><li><strong>Pros:</strong> Blazing fast <strong>O(1)</strong> lookup. Conceptually simple and very effective.</li><li><strong>Cons:</strong> Uses a fixed block of memory and is limited to the character set defined by the array size (e.g.,Â ASCII).</li></ul><h3>Built-in String Operations</h3><p>These methods rely on familiar String classÂ methods.</p><h4>7. String.contains()</h4><pre>private static final String VOWELS = &quot;aeiouAEIOU&quot;;<br>public boolean hasVowels(String text) {<br>    for (var vowel : VOWELS.toCharArray()) {<br>        if (text.contains(String.valueOf(vowel))) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It loops through each <em>vowel</em> and checks if the <em>entire input string</em> containsÂ it.</li><li><strong>Pros:</strong> Very easy to write and understand.</li><li><strong>Cons:</strong> Extremely inefficient. Each call toÂ .contains() can re-scan the entire inputÂ string.</li></ul><h4>8. String.replace()</h4><p>A creative but impractical approach that demonstrates string manipulation.</p><pre>public boolean hasVowels(String text) {<br>    var current = text;<br>    var originalLength = text.length();    <br>    for (char vowel : &quot;aeiouAEIOU&quot;.toCharArray()) {<br>        current = current.replace(String.valueOf(vowel), &quot;&quot;);<br>        if (current.length() != originalLength) return true;<br>    }<br>    return false;<br>}</pre><ul><li><strong>How it works:</strong> It tries to replace each vowel with an empty string. If the string length changes at any point, a vowel must have beenÂ present.</li><li><strong>Pros:</strong> A unique way to think about theÂ problem.</li><li><strong>Cons:</strong> Very inefficient due to the creation of new string objects in aÂ loop.</li></ul><h3>The Power of Patterns: Regex-Based Implementations</h3><p>Regular expressions are the ultimate tool for pattern matching inÂ text.</p><h4>9. Simple RegexÂ find()</h4><p>A concise and powerful way to solve the problem using aÂ pattern.</p><pre>private static final Pattern VOWEL_PATTERN = Pattern.compile(&quot;[aeiouAEIOU]&quot;);<br>public boolean hasVowels(String text) {<br>    return VOWEL_PATTERN.matcher(text).find();<br>}</pre><ul><li><strong>How it works:</strong> A Pattern object is compiled once to represent &quot;any character in this set.&quot; The matcher(text).find() method then efficiently searches the string for the first occurrence.</li><li><strong>Pros:</strong> Clean, highly readable, and easily extensible for more complex patterns.</li><li><strong>Cons:</strong> Regex engines carry some overhead, so this may not be as fast as direct array or bit-set lookup for this simpleÂ task.</li></ul><h4>10. Regex replaceAll()</h4><p>Another regex-based approach that works by removing allÂ matches.</p><pre>private static final String VOWELS_MATCH = &quot;[aeiouAEIOU]&quot;;<br>public boolean hasVowels(String text) {<br>    var withoutVowels = text.replaceAll(VOWELS_MATCH, &quot;&quot;);<br>    return withoutVowels.length() != text.length();<br>}</pre><ul><li><strong>How it works:</strong> It replaces all vowels in the string with nothing and then checks if the stringâ€™s length hasÂ changed.</li><li><strong>Pros:</strong> Declarative and easy to understand what itâ€™sÂ doing.</li><li><strong>Cons:</strong> Inefficient because it processes the <em>entire</em> string and creates a new one, even if the first character is aÂ vowel.</li></ul><h3>Benchmark</h3><p>To objectively compare these Java vowel-checking methods, weâ€™re using the <a href="https://github.com/openjdk/jmh"><strong>Java Microbenchmark HarnessÂ (JMH)</strong></a>.</p><pre>@BenchmarkMode(Mode.AverageTime)<br>@OutputTimeUnit(TimeUnit.NANOSECONDS)<br>@State(Scope.Benchmark)<br>@Fork(value = 2, warmups = 1)<br>@Warmup(iterations = 5, time = 1)<br>@Measurement(iterations = 10, time = 1)<br>public class VowelCheckerBenchmark {</pre><p>The benchmarks were run on <strong>OpenJDK 25</strong> (Temurin-25+36) with -Xms1g -Xmx1g -XX:+UseG1GC. It measures the <strong>average execution time per operation in nanoseconds</strong>, running in a <strong>shared benchmark state</strong>, with <strong>2 forks (each doing 1 warmup fork)</strong>, <strong>warming up for 5 iterations of 1 second</strong> each, and then measuring <strong>over 10 iterations of 1 secondÂ each</strong>.</p><pre><br>| Method           | withVowels (ns/op) | withoutVowels (ns/op) |<br>|------------------|--------------------|-----------------------|<br>| anyMatchContains | 30.301             | 858.955               |<br>| anyMatch         | 12.123             | 490.683               |<br>| bitSet           | ğŸŸ¢ **1.481**       | 64.707                |<br>| byteMask         | ğŸŸ¢ **1.297**       | 69.118                |<br>| charArray        | ğŸŸ¢ **1.296**       | ğŸŸ¢ **54.632**         |<br>| contains         | 15.513             | 157.358               |<br>| loopIn           | 8.972              | 211.650               |<br>| loopOr           | 8.242              | 174.308               |<br>| nestedFor        | 10.896             | 382.267               |<br>| recursion        | 1.743              | ğŸ”´ **1555.377**       |<br>| regexReplace     | ğŸ”´ **428.105**     | 118.510               |<br>| regex            | 14.023             | 75.144                |<br>| stringReplace    | 59.367             | 61.914                |</pre><h3>Wrapping up</h3><h4>Top performers (1â€“2 ns with vowels, ~55â€“70 nsÂ without)</h4><ul><li>charArray â†’ <strong>1.296 nsÂ </strong>(best)</li><li>byteMask â†’ <strong>1.297Â ns</strong></li><li>bitSet â†’ <strong>1.481Â ns</strong></li></ul><p><strong>Without vowels:</strong></p><ul><li>charArray â†’ <strong>54.6 ns</strong>Â (best)</li><li>bitSet â†’ 64.7Â ns</li><li>byteMask â†’ 69.1Â ns</li></ul><p>The <strong>lookup-based methods (</strong><strong>charArray, </strong><strong>bitSet, </strong><strong>byteMask) are clearÂ winners</strong>:</p><ul><li>Tiny cost when vowel foundÂ early.</li><li>Linear, but still very fast when scanningÂ fully.</li></ul><h3>Ranking summary</h3><h4>âœ… Best (production-ready, fastest,Â stable)</h4><ul><li>charArray (fastest, simplest, predictable)</li><li>bitSet (slightly slower, butÂ elegant)</li><li>byteMask (comparable, just moreÂ obscure)</li></ul><h4>âš–ï¸ Acceptable (slower but usable if clarityÂ matters)</h4><ul><li>regex (â‰ˆ14 ns / 75Â ns)</li><li>contains (â‰ˆ15 ns / 157Â ns)</li></ul><h4>âš ï¸ Slower (avoid for hotÂ paths)</h4><ul><li>loopIn, loopOr, nestedFor (hundreds of ns worstÂ case)</li></ul><h4>ğŸŒ Worst</h4><ul><li>recursion (unstable, explodes withoutÂ vowels)</li><li>regexReplace (hundreds of ns, allocates)</li><li>stringReplace (~60 ns always, wasteful)</li></ul><h3>Takeaways</h3><ul><li>The <strong>JVM</strong> is <em>very</em> good at optimizing simple array/bit-set lookup.</li><li><strong>Low-Level is King for Speed:</strong> For a simple task like vowel checking, direct array lookup (charArray) or bit-fiddling (byteMask, bitSet) are the most efficient.</li><li><strong>If you want a balance of readability + acceptable performance:</strong> regex or contains.</li><li><strong>Streams and Recursion areÂ Costly</strong></li></ul><p>You can find all the code onÂ <a href="https://github.com/marconak-matej/vowels">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bf2e313766b1" width="1" height="1" alt="">

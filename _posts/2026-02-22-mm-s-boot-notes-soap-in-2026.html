---
layout: post
title: "[MM’s] Boot Notes — SOAP in 2026"
canonical_url: https://marconak-matej.medium.com/mms-boot-notes-soap-in-2026-9dd75ccc4d21?source=rss-f1368b7746f7------2
tag:
- java
- web-services
- programming
- spring-boot
---

<h4>Why Contract-First Design Is Becoming Relevant Again — and SOAP Already Solved It.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Z6nlRSkmTVf0Ga1qRr3CVA.png" /><figcaption>SOAP in 2026</figcaption></figure><p>Choosing between REST, gRPC, GraphQL or SOAP isn’t a personality test. It’s an architectural decision driven by constraints.</p><p><strong>REST</strong> dominates public APIs.<br><strong>gRPC</strong> thrives in high-throughput microservices.<br><strong>GraphQL</strong> shines in frontend-heavy systems.</p><p>SOAP was supposed to be dead by now. Yet in finance, healthcare and government, it quietly runs some of the most critical integrations in the world — not because teams prefer XML, but because regulators demand the kind of formal, enforceable contracts that SOAP was built to deliver.</p><h4>⚡ TL;DR (Quick Recap)</h4><ul><li><strong>SOAP</strong> remains standard in regulated domains due to strict contracts and WS-Security.</li><li><strong>Spring Boot + Spring-WS</strong> makes <strong>SOAP</strong> development clean and testable.</li><li>The production flow is: <strong>XSD</strong> → generate classes → wire beans → implement endpoint → map faults → test.</li><li><strong>SOAP</strong> wins on governance and message-level security — not raw throughput.</li></ul><h4>The 2026 Stack</h4><p>We’re operating in:</p><ul><li>Java 21+</li><li>Jakarta EE 11</li><li>Spring Framework 7</li><li>Spring Boot 4</li></ul><p>The core dependency:</p><pre>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><pre>&lt;!-- WSDL Support --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;wsdl4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;<br>&lt;/dependency&gt;</pre><p>For schema-driven code generation:</p><pre>&lt;plugin&gt;<br>    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;<br>    &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;<br>    &lt;version&gt;4.1.0&lt;/version&gt;<br>    &lt;executions&gt;<br>        &lt;execution&gt;<br>            &lt;goals&gt;&lt;goal&gt;xjc&lt;/goal&gt;&lt;/goals&gt;<br>        &lt;/execution&gt;<br>    &lt;/executions&gt;<br>    &lt;configuration&gt;<br>        &lt;sources&gt;src/main/resources/schema&lt;/sources&gt;<br>        &lt;outputDirectory&gt;target/generated-sources/jaxb&lt;/outputDirectory&gt;<br>        &lt;packageName&gt;io.github.mm.soap.gen&lt;/packageName&gt;<br>    &lt;/configuration&gt;<br>&lt;/plugin&gt;</pre><p>Change the <strong>XSD</strong>. Regenerate. Never edit generated classes manually.</p><h4>Contract-First: Start With the Schema</h4><p>SOAP development begins with the contract.</p><p>Minimal example:</p><pre>&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;<br>           targetNamespace=&quot;http://github.io/mm/soap/demo&quot;<br>           elementFormDefault=&quot;qualified&quot;&gt;<br>    &lt;xs:element name=&quot;GetDemoRequest&quot;&gt;<br>        &lt;xs:complexType&gt;<br>            &lt;xs:sequence&gt;<br>                &lt;xs:element name=&quot;id&quot; type=&quot;xs:string&quot;/&gt;<br>            &lt;/xs:sequence&gt;<br>        &lt;/xs:complexType&gt;<br>    &lt;/xs:element&gt;<br>    &lt;xs:element name=&quot;GetDemoResponse&quot;&gt;<br>        &lt;xs:complexType&gt;<br>            &lt;xs:sequence&gt;<br>                &lt;xs:element name=&quot;id&quot; type=&quot;xs:string&quot;/&gt;<br>                &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;<br>            &lt;/xs:sequence&gt;<br>        &lt;/xs:complexType&gt;<br>    &lt;/xs:element&gt;<br>&lt;/xs:schema&gt;</pre><p>Running mvn generate-sources produces typed Java classes.</p><p>This is SOAP’s core strength: strict, versioned contracts enforced at compile time and runtime.</p><h4>Wiring Spring-WS</h4><p>Spring-WS relies on four infrastructure beans.</p><pre>@Configuration<br>@EnableWs<br>public class WebServiceConfig {<br>    @Bean<br>    public ServletRegistrationBean&lt;MessageDispatcherServlet&gt;<br>        messageDispatcherServlet(ApplicationContext context) {<br>        var servlet =<br>                new MessageDispatcherServlet();<br>        servlet.setApplicationContext(context);<br>        servlet.setTransformWsdlLocations(true);<br>        return new ServletRegistrationBean&lt;&gt;(servlet, &quot;/ws/*&quot;);<br>    }<br>    @Bean(&quot;demo-service&quot;)<br>    public DefaultWsdl11Definition wsdl(XsdSchema schema) {<br>        var def =<br>                new DefaultWsdl11Definition();<br>        def.setSchema(schema);<br>        def.setLocationUri(&quot;/ws&quot;);<br>        def.setPortTypeName(&quot;DemoServicePortType&quot;);<br>        def.setTargetNamespace(<br>                &quot;http://github.io/mm/soap/demo&quot;);<br>        return def;<br>    }<br>    @Bean<br>    public XsdSchema demoSchema() {<br>        return new SimpleXsdSchema(<br>                new ClassPathResource(&quot;schema/demo.xsd&quot;));<br>    }<br>    @Bean<br>    public Jaxb2Marshaller marshaller() {<br>        Jaxb2Marshaller m = new Jaxb2Marshaller();<br>        m.setContextPath(&quot;io.github.mm.soap.gen&quot;);<br>        return m;<br>    }<br>}</pre><p>Data flow:</p><pre>HTTP → MessageDispatcherServlet → Endpoint → Service → JAXB → SOAP Envelope → Response</pre><p>No manual XML handling required.</p><h4>Implementing the Endpoint</h4><pre>@Endpoint<br>public class SoapDemoEndpoint {<br>    private static final String NAMESPACE =<br>            &quot;http://github.io/mm/soap/demo&quot;;<br>    private final DemoService service;<br>    public SoapDemoEndpoint(DemoService service) {<br>        this.service = service;<br>    }<br>    @PayloadRoot(namespace = NAMESPACE,<br>                 localPart = &quot;GetDemoRequest&quot;)<br>    @ResponsePayload<br>    public GetDemoResponse getDemo(<br>            @RequestPayload GetDemoRequest request) {<br>        var demo = service.getDemo(request.getId());<br>        var response = new GetDemoResponse();<br>        response.setId(demo.id());<br>        response.setName(demo.name());<br>        return response;<br>    }<br>}</pre><p>Domain layer with Java 21 records:</p><pre>public record Demo(String id, String name) {}<br><br>@Service<br>public class DemoService {<br>    // .....<br>    public Demo getDemo(String id) {<br>        return Optional.ofNullable(store.get(id))<br>                .orElseThrow(() -&gt;<br>                    new NotFoundException(<br>                        &quot;Demo not found: &quot; + id));<br>    }<br>}</pre><p>Business logic stays clean and framework-independent.</p><h4>Production Error Handling: SOAP Faults</h4><p>SOAP communicates errors via structured &lt;soap:Fault&gt; elements.</p><p>Example:</p><pre>&lt;soap:Fault&gt;<br>  &lt;faultcode&gt;soap:Server&lt;/faultcode&gt;<br>  &lt;faultstring&gt;Demo not found&lt;/faultstring&gt;<br>&lt;/soap:Fault&gt;</pre><p>Map exceptions centrally:</p><pre>@Configuration<br>public class SoapExceptionHandler<br>        extends SoapFaultMappingExceptionResolver {<br>      public SoapExceptionHandler() {<br>        var mappings = new Properties();<br>        mappings.setProperty(IllegalArgumentException.class.getName(),&quot;CLIENT&quot;);<br>        mappings.setProperty(NotFoundException.class.getName(),&quot;SERVER&quot;);<br>        var defaultFault = new SoapFaultDefinition();<br>        defaultFault.setFaultCode(SoapFaultDefinition.SERVER);<br>        defaultFault.setFaultStringOrReason(&quot;Unexpected server error&quot;);<br>        setExceptionMappings(mappings);<br>        setDefaultFault(defaultFault);<br>        setOrder(Integer.MAX_VALUE - 1);<br>    }<br>}</pre><p>Guideline:</p><ul><li><strong>CLIENT</strong> → validation problems</li><li><strong>SERVER</strong> → system failures</li></ul><p>Never expose stack traces in production faults.</p><h4>Testing the Endpoint</h4><pre>@SpringBootTest(<br>    webEnvironment =<br>        SpringBootTest.WebEnvironment.DEFINED_PORT)<br>class SoapDemoEndpointTest {<br>    @Autowired<br>    private WebServiceTemplate template;<br>    @Test<br>    void getDemo_success() {<br>        var request =<br>                new GetDemoRequest();<br>        request.setId(&quot;demo-1&quot;);<br>        var response =<br>                (GetDemoResponse)<br>                template.marshalSendAndReceive(<br>                    &quot;http://localhost:8088/ws/demo-service&quot;,<br>                    request);<br>        assertThat(response.getName())<br>                .isEqualTo(&quot;Test Demo&quot;);<br>    }<br>    @Test<br>    void getDemo_notFound_returnsFault() {<br>        var request =<br>                new GetDemoRequest();<br>        request.setId(&quot;invalid&quot;);<br>        assertThrows(<br>            SoapFaultClientException.class,<br>            () -&gt; template.marshalSendAndReceive(<br>                &quot;http://localhost:8088/ws/demo-service&quot;,<br>                request)<br>        );<br>    }<br>}</pre><p>A production SOAP service must be predictable under failure.</p><h4>Where SOAP Fits in 2026</h4><p>Let’s be honest.</p><p><strong>REST</strong></p><ul><li>Best for public APIs</li><li>Developer-friendly</li><li>Flexible, loosely enforced contracts</li></ul><p><strong>gRPC</strong></p><ul><li>High performance</li><li>Strong contracts via Protobuf</li><li>Ideal for internal microservices</li></ul><p><strong>GraphQL</strong></p><ul><li>Client-driven data fetching</li><li>Powerful, but complex</li></ul><p><strong>SOAP</strong></p><ul><li>Strict WSDL + XSD contracts</li><li>Message-level encryption (WS-Security)</li><li>High interoperability across enterprises</li><li>Strong governance</li></ul><p>SOAP does not compete on simplicity. It competes on precision.</p><h4>Final Takeaways</h4><p>SOAP in 2026 is not about nostalgia. It’s about specialization.</p><p>Spring Boot and modern Java remove much of the friction that once made SOAP painful. With contract-first development, structured fault handling and proper testing, you can build services that meet strict regulatory and interoperability demands.</p><p>The right protocol depends on your constraints — not trends. And sometimes, the “old” solution is still the most disciplined one.</p><p>You can find example of code on <a href="https://github.com/marconak-matej/spring-boot-4-boot-notes">GitHub</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9dd75ccc4d21" width="1" height="1" alt="">
